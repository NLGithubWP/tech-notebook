<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link media="all" rel="stylesheet" type="text/css" href="https://nlgithubwp.github.io/css/pygments.css" />
   <meta property="og:url" content="https://nlgithubwp.github.io/journal/212/" />
   <link rel="canonical" href="https://nlgithubwp.github.io/journal/212/" />


  <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
<link rel="icon" href="/tech-notebook/favicon.ico?" type="image/x-icon">

    <meta name="description" content="It's the niceties that make the difference fate gives us the hand, and we play the cards.">

    <title>PostgreSQL 14 Internals - NoteBook</title>

    <link rel="canonical" href="https://nlgithubwp.github.io/tech-notebook/journal/212/">

<!-- CSS -->
	
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/tech-notebook/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/tech-notebook/css/main.css">
    <link rel="stylesheet" href="/tech-notebook/css/galleries.css">
     <link rel="stylesheet" href="/tech-notebook/css/super-search.css">
    <link rel="stylesheet" href="/tech-notebook/css/magnificpopup.css">
    <link rel="stylesheet" href="/tech-notebook/css/pygments.css">

    <!-- Custom Fonts -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Josefin+Sans:400,600&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->


</head>


<head>

</head>

<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top" style="margin-right:1em; z-index: 1;">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <i class="fa fa-bars fa-lg"></i>
            </button>
            <a href="/tech-notebook/" title="HOME"><img src="/tech-notebook/img/logos/logo6.png" alt="logo" style="width:150px;cursor:pointer;margin-top:15px;"/></a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right" style="margin-right:1em; text-shadow: -.025em -.025em 0 rgba(0, 133, 161, 0.75), .025em -.025em 0 rgba(0, 133, 161, 0.75), -.025em .025em 0 rgba(0, 133, 161, 0.75), .025em .025em 0 rgba(0, 133, 161, 0.75);">
               
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/gallery/">GALLERY</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/journal/">JOURNAL</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/about/">ABOUT</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/resume/">CV</a></li>
            
          
        
                            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>



    <html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        
        <meta name="viewport" content="width=device-width">

<link href="/tech-notebook/css/tags-wrap.css" rel="stylesheet" />
  
    </head>
    <body>
  



<article>
<!-- Post Header -->
<header class="intro-header" style="background-image: url('/tech-notebook/')">
    <div class="container">
        <div class="row">
            <div class="post-heading">
                    <h1 style="color: #acd578;">PostgreSQL 14 Internals</h1>
                    
                    <span class="meta">Posted on April 17, 2024</span>

<span class="time-tag-categ" style="font-size:.7em;background-color: rgba(128, 128, 128, 0.45);">


<i class="fa fa-clock-o"></i>&nbsp;
22 minute read



 


  
   &sim; Filed in <i class="fa fa-briefcase"></i>&nbsp;:&nbsp;<a href="/tech-notebook/journal/category/A paper note/" data-toggle="tooltip" title="Other posts filed in A paper note category" rel="tag">A paper note</a>    
                    
   </span>

            </div>
        </div>
    </div>
</header>

<!-- Post Content -->

    <div class="container">
        <div class="row">
            

             <h1 id="notes">Notes</h1>

<p>Buffer states retrieval UDF on page 171 could be used as states for RL.</p>

<p>pg_statio_all_tables on page 177 could show how many pages are read for a table into the buffer cache.</p>

<p><code class="language-plaintext highlighter-rouge">ANALYZE big;</code> updates the statistics of the table for the query planner. It is an essential step for PostgreSQL to make informed decisions about query execution plans.</p>

<p>Page 184 has an SQL to check what fraction of each relation is cached, and whether this data is hot (a page is considered hot here if its usage count is bigger than one.</p>

<p>enable <strong>debug_print_parse</strong> parameter in PostgreSQL, we can view the full parse tree in the server log.</p>

<p>If you want to explore full plan trees, dump them into the server log by enabling the <strong>debug_print_plan</strong> parameter. But in practice, it is usually enough to view the text representation of the plan displayed by the <strong>EXPLAIN</strong> command.</p>

<p>Visibility of the table as on page 308 may be used.</p>

<p>SQL in 315 can update the default cardinalities.</p>

<p>The correlation field on page 323 introduces some methods to get column correlation related to the disk.</p>

<p>SQL on page 326 can show all statistics of the column for an expression.</p>

<p>Statistics dependence can be created (page 329), and is useful.</p>

<p>The query on page 349 will tell how to able or disable the query. force_parallel_mode</p>

<h1 id="introduction">Introduction</h1>

<h2 id="data-organization">Data organization</h2>

<p>single Postgresql instance can serve several databases at a time. They are called database clusters.</p>

<p><strong>Logical Storage</strong></p>

<p>A catalog** in PostgreSQL is a set of system tables that store metadata about all database objects in a cluster, such as tables, indexes, functions, and schemas. This metadata includes details like object names, data types, and access permissions.</p>

<ul>
  <li>Catalog tables are all begin with pg_</li>
</ul>

<p><strong>Schema</strong> is a namespace with many objectives. predefined schemas:</p>

<ul>
  <li>public (for user objectives), pg_catalog (system catalog tables), information_schema (view for system catalog), pg_toast, og_temp</li>
</ul>

<p><strong>Relations</strong>: all tables, indexes, and views are called relations.</p>

<ul>
  <li>all data associated with a relation is stored in several forks, a fork is basically a single file of 1GB (can be configured), and the file is also named a <strong>segment</strong>. The sequence number of the segment is added to the end of its filename.</li>
</ul>

<p><strong>Physical Storage</strong></p>

<p><strong>PGDATA</strong> is a directory that contains all the files related to the database cluster, at the beginning, it contains</p>

<ul>
  <li>template0 database: is used for restoring data or creating a database with a different encoding.</li>
  <li>template1 database: is a template for all other databases that a user can create (by copying template1) in the cluster.</li>
</ul>

<p><strong>Tablespaces</strong> is a physical data layout, it is a dir in the file system, database stores the data in several <strong>tablespaces</strong>. During the database initialization, two tablespaces are created:</p>

<ul>
  <li>pg_default:  default tablespace unless another tablespace is selected for this purpose.</li>
  <li>pg_global: system catalog objects common to the whole cluster.</li>
  <li>postgres database uses tablespace <strong>xyzzy</strong> as the default one</li>
</ul>

<p><strong>Pages</strong>. To facilitate I/O, all files are logically split into pages (or blocks), which represent the minimum amount of data that can be read or written. Consequently, many internal PostgreSQL algorithms are tuned for page processing.</p>

<p><strong>TOAST</strong>: Each row must fit a single page: there is no way to continue a row on the next page. To store long rows, PostgreSQL uses a special mechanism called TOAST (The Oversized Attributes Storage Technique).
Long attribute values are separated into smaller chunks, which will be stored in the TOAST table. The chunk size is decided such that one page of the TOAST table can contain four rows.</p>

<p>Each TOAST table has three columns, chunk_id, chunk_seq, and length. columns</p>

<p>For index, the toast mechanism can offer only compression.</p>

<p>PostgreSQL supports a few strategies:</p>

<ul>
  <li>plain means that ToAST is not used (this strategy is applied to data types that are known to be“short,” such as the integer type).</li>
  <li>extended allows both compressing attributes and storing them in a separate TOAST table.</li>
  <li>external implies that long attributes are stored in the ToAST table in an uncom- pressed state.</li>
  <li>main requires long attributes to be compressed first; they will be moved to the TOAST table only if compression does not help.</li>
</ul>

<p>Due to TOAST, each table will have at least three files (or “forks”): <strong>the main data file, the TOAST data file, and the TOAST index file.</strong></p>

<h1 id="process">Process</h1>

<p>A PostgreSQL server instance consists of <strong>several interacting processes.</strong></p>

<p><code class="language-plaintext highlighter-rouge">postmaster</code>: spawns all other processes and supervises them (restart the failed one if there is one).</p>

<p><code class="language-plaintext highlighter-rouge">startup</code> restores the system after a failure.
<code class="language-plaintext highlighter-rouge">auto vacuum</code> removes stale data from <strong>tables and indexes.</strong></p>

<p><code class="language-plaintext highlighter-rouge">checkpointer</code> executes checkpoints.
<code class="language-plaintext highlighter-rouge">writer</code> flushes dirty pages to the disk.
<code class="language-plaintext highlighter-rouge">stats collector</code> collects usage statistics for the instance.</p>

<p><code class="language-plaintext highlighter-rouge">wal writer</code> writes WAL entries to disk.
<code class="language-plaintext highlighter-rouge">wal sender</code> sends WAL entries to a replica.
<code class="language-plaintext highlighter-rouge">wal receiver</code> gets WAL entries on a replica</p>

<p>Drawbacks:</p>

<ul>
  <li>static shared memory allocation does not allow resizing structures like buffer cache on the fly;</li>
  <li>parallel algorithms are hard to implement and less efficient than they could be;  (due to inefficient sharing state via IPC.)</li>
  <li>sessions are tightly bound to processes.</li>
</ul>

<p>To enable <strong>process interaction</strong>, the postmaster allocates shared memory, which is available to all the processes.</p>

<p>PostgreSQL uses a large portion of the shared memory for caching frequently accessed data.</p>

<p>One client connection will trigger spawning a new process, it is until the session continues or lost. This is inefficient and may cause problems when too many clients try to connect.</p>

<p>One solution is using the connection pool (PgBouncer or Odyssey), but this limits the maximum connection number.</p>

<p>Since the process uses MVCC in building various isolation levels, it will generate many old versions of data, which can be deleted by using a vacuum.</p>

<h1 id="memory">Memory</h1>

<p>Lots of shared memory is used to store the buffered cache.</p>

<p>In the buffer search and eviction, it uses a clock sweep algorithm, which goes around the buffer cache and reduces the usage count for each cached page by one as it passes.</p>

<p>The first unpinned buffer with the zero counts found by the clock hand will be cleared.</p>

<p>Thus, the usage count is incremented each time the buffer is accessed (that is, pinned), and reduced when the buffer manager is searching for pages to evict.
As a result, the least recently used pages are evicted first, while those that have been accessed more often will remain in the cache longer.</p>

<p>Each process has its cache, which stores the <strong>Temporary Table.</strong> e.g., CREATE TEMPORARY TABLE tmp AS SELECT 1;</p>

<h1 id="query-execution">Query Execution</h1>

<p>parsed, transformed, planned, executed.</p>

<h2 id="parser-text--parse-tree">Parser: Text =&gt; Parse Tree</h2>

<p>It uses a <strong>lexer</strong> (previously used in compilers, interpreters, and many types of text processing systems ) to split the query text into a set of lexemes (such as keywords, string literals, and numeric literals).</p>

<p>It then uses a <strong>parser</strong> to validate this set against the SQL language grammar, and then build a <strong>Parse Tree</strong>.</p>

<p>Then it performs semantic analysis to determine whether whether the database contains any tables or other objects that this query refers to by name, and whether the user has permission to access these objects by checking the catalog.</p>

<h2 id="transformation-parse-tree--rewriten-parse-tree">Transformation: Parse Tree =&gt; Rewriten Parse Tree</h2>

<p>This rewrites the query:</p>

<ul>
  <li>replace the view in the parse tree with the subtree, security reason.</li>
</ul>

<p>Transformation is based on the query rewrite rule system. https://www.postgresql.org/docs/14/rules.html</p>

<h2 id="planningoptimizer-rewriten-parse-tree--plan-tree">Planning/Optimizer: Rewriten Parse Tree =&gt; Plan Tree</h2>

<p>Several join tables =&gt; grow the plans, the optimal and non-optimal plans can differ by orders of magnitude.</p>

<p>Optimizer uses a <strong>dynamic programming algorithm combined with some heuristics</strong> to reduce the search space.</p>

<p>A genetic algorithm** is used to optimize the query if <strong>geqo_threshold</strong> is set, which defines the number of elements at one level to optimize. <code class="language-plaintext highlighter-rouge">optimizer/gecko/</code></p>

<p>Cost-based optimizer estimates the resources required for execution. (<strong>I/O operation CPU cycles</strong>)</p>

<ul>
  <li>Startup Cost: Prepare for the node execution.
    <ul>
      <li>The cost associated with setting up the necessary data structures, loading initial data into memory, and any other preparatory tasks required before actual data processing starts. For example, if a query involves a sequential scan of a table, the startup cost would include the <strong>time and resources</strong> needed to locate the table on disk.</li>
    </ul>
  </li>
  <li>total cost: comprises all the expenses incurred by fetching the result.</li>
</ul>

<p>If using the cursor, it reads data row by row, if not, it reads the whole result at once.  Different methods differ in plan generation.</p>

<ul>
  <li>w cursor, it minimizes the total cost.</li>
  <li>w/o a cursor, it minimizes the cost of cursor_tuple_fraction.</li>
</ul>

<p>The cardinality estimation calculations rely on the <strong>collected statistics</strong>,  such as table sizes and data distribution in table columns.</p>

<h3 id="cardinality-estimation">Cardinality Estimation</h3>

<p>Steps:</p>

<ul>
  <li>Estimate the number of input rows of each node. =&gt; 1</li>
  <li>Estimate the <strong>selectivity</strong> of the node == the <strong>fraction of input rows</strong> that will remain at the output. =&gt; 2</li>
  <li>CE of a node = multiplying the <strong>=&gt;1 by the =&gt; 2</strong> applied at that node.</li>
</ul>

<p>Methods to compute CE:</p>

<ul>
  <li>
    <p>CE of filter condition: each column is considered independently. Thus the below functions may have errors.
sel_{x and y} = sel_x*sel_y,</p>

    <p>sel_{x or y} = 1- (1-sel_x)(1-sel_y)</p>
  </li>
  <li>
    <p>CE of join: Cartesian product. If the first dataset has <code class="language-plaintext highlighter-rouge">N</code> rows and the second dataset has <code class="language-plaintext highlighter-rouge">M</code> rows, then their Cartesian product results in <code class="language-plaintext highlighter-rouge">N x M</code> rows. (maximum possible number of rows that could result from a join)</p>
  </li>
</ul>

<h3 id="cost-model">Cost Model:</h3>

<p>disk I/o and CPU resources</p>

<p>cost =sF(CE)</p>

<p>some operation has no prerequisites, so their execution starts immediately. while other has. e.g., sort needs to wait to collect all other data. The startup cost of such nodes is usually higher than zero.</p>

<h1 id="execution">Execution</h1>

<p>executor opens a portal in backend memory, which keeps the state of the query currently being executed.</p>

<p>The execution process starts from the root,</p>

<ul>
  <li>nested loop join does not need to wait until all rows are received to start producing output. It processes and passes on rows as soon as they meet the join condition.</li>
</ul>

<p>As for the join operation, it uses a <strong>work_mem</strong> to decide the maximum amount of memory that each database operation, such as sorting or hash joins, can use before spilling to disk.</p>

<p>PostgresoL has <strong>no global cache for queries</strong></p>

<h1 id="statistics-in-database">Statistics in database</h1>

<p>During analysis, For analysis purposes, 300× 100 default_statistics_target random rows are sampled. The sample size required to build statistics of a particular accuracy has a low dependency on the volume of analyzed data, so the size of the table is not taken into account.</p>

<p>It uses <strong>default_statistics_target</strong> to decide how many to use to decide the statistics for each column.</p>

<h3 id="basic-statistics">Basic Statistics</h3>

<ul>
  <li>Number of tuples in a relation (<strong>rel-tuples</strong>)</li>
  <li>Relation size, in pages (<strong>replaces</strong>)</li>
  <li>Number of pages tagged in the visibility map (<strong>relallvisible</strong>)</li>
</ul>

<h3 id="null-values">Null values</h3>

<h3 id="distinct-values">Distinct values</h3>

<ul>
  <li>There is a <strong>n_distinct</strong> variable for each column</li>
</ul>

<h3 id="most-common-values">Most common values</h3>

<p>each column has two features</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">most_common_vals</code></strong>:</li>
  <li><strong><code class="language-plaintext highlighter-rouge">most_common_freqs</code></strong>:</li>
</ul>

<h3 id="histogram">Histogram</h3>

<p>If distinct values are too many to be stored in an array, PostgresoL employs a histogram.</p>

<p>The histogram is divided into multiple small ranges, each with the same number of values.</p>

<p>The histogram is used for operations like estimating the selectivity of <strong>greater than and less than</strong> conditions.</p>

<h2 id="correlation">Correlation</h2>

<p>correlation between the physical order of data and the logical order defined by comparison operations.</p>

<p>This is used for the cost estimation of index scans.</p>

<h2 id="expression-statistics">Expression Statistics</h2>

<p>For customer functions or transformations to a column in a SQL query, PostgreSQL’s query planner may struggle to accurately estimate the distribution of the data after the transformation. It uses default ones, 0.5%.</p>

<p>The 0.5% figure is a cautious estimate, assuming that any given transformed value (like extracting a month, converting strings, or applying mathematical operations) might only match a small fraction of total rows.</p>

<p>Therefore, we need to collect expression statistics ourselves.</p>

<ul>
  <li>Create extended-expression statistics by using CREATE STATISTICS.</li>
  <li>Statistics index for expression indexes. Which can update automatically.</li>
</ul>

<h2 id="multivariate-statistics">multivariate statistics</h2>

<p>span several table columns.</p>

<p>There is a <strong>well-known problem of correlated predicates</strong>, planner assumes predicates do not depend on each other, so the selectivity is estimated as the product of the selectivities of filter conditions combined by logical <strong>and</strong>.
As a result, the planner will <strong>underestimate</strong> the row number.</p>

<ul>
  <li>
    <p>plain index scan wins for fetching a small number of tuples,</p>
  </li>
  <li>bitmaps can win for a somewhat larger number of tuples,</li>
  <li>season wins if you’re fetching a large percentage of the whole table.</li>
</ul>

<p>Dependence can be created between columns.</p>

<h2 id="summary">Summary</h2>

<p>The statistics gathered by PostgreSQL’s query optimizer impact various parts of a query, particularly in the following areas:</p>

<ol>
  <li><strong>Where Conditions</strong>:
    <ul>
      <li><strong>Basic Statistics</strong> such as <code class="language-plaintext highlighter-rouge">rel-tuples</code> and <code class="language-plaintext highlighter-rouge">relpages</code> help in estimating the overall size of the data and the amount of data to process, influencing whether a sequential scan or an index scan is more efficient.</li>
      <li><strong>Distinct Values (<code class="language-plaintext highlighter-rouge">n_distinct</code>)</strong> and <strong>Most Common Values (<code class="language-plaintext highlighter-rouge">most_common_vals</code> and <code class="language-plaintext highlighter-rouge">most_common_freqs</code>)</strong> are crucial for estimating the selectivity of filters in the WHERE clause. These statistics determine how many rows are likely to match a given condition, especially when filtering on specific column values.</li>
      <li><strong>Histograms</strong> are used to estimate the selectivity for range conditions (e.g., <code class="language-plaintext highlighter-rouge">column &gt; value</code> or <code class="language-plaintext highlighter-rouge">column &lt; value</code>). They help the optimizer understand the distribution of data within a column when exact matches are not feasible to calculate due to a high number of distinct values.</li>
    </ul>
  </li>
  <li><strong>Join Conditions</strong>:
    <ul>
      <li><strong>Multivariate Statistics</strong> play a significant role in join conditions by helping to estimate the selectivity and distribution of values that result from joining tables. These are particularly useful when columns from different tables are correlated, which might not be apparent through individual column statistics.</li>
      <li><strong>Expression Statistics</strong> and <strong>Correlation</strong> data influence the optimizer’s decision on which type of join (nested loop, hash join, or merge join) is most efficient based on the expected size of join outputs and the physical order of data.</li>
    </ul>
  </li>
  <li><strong>Index Scans</strong>:
    <ul>
      <li>The <strong>correlation between physical and logical order of data</strong> greatly affects whether an index scan is beneficial. High correlation means that the data is physically stored in a way that aligns well with the index, making index scans faster and more predictable.</li>
    </ul>
  </li>
</ol>

<p>In essence, these statistics help PostgreSQL’s optimizer make informed decisions about every aspect of query execution—from choosing scan types to optimizing joins and applying filters—thereby enhancing performance by selecting the most efficient execution paths based on data distribution and query structure.</p>

<h1 id="table-access-methods">Table Access Methods</h1>

<p>Postgresql allows you to plug in various engines (pluggable storage engines).</p>

<p>Engine defines</p>

<ul>
  <li>tuple format and data structure</li>
  <li>table <strong>scan</strong> implementation and cost estimation</li>
  <li>implementation of insert, delete, update, and lock operations</li>
  <li>visibility rules.</li>
  <li>vacuum and analysis procedures.</li>
</ul>

<p>A default storage engine is a <strong>heap</strong>, optional ones are zheac and <strong>zedstore</strong> (columnar storage).</p>

<h2 id="sequential-scans">Sequential scans.</h2>

<p>The scan process will use an extra buffer ring, which not affect the main buffer cache.</p>

<p>multiple processes can share the same buffer ring, thus reading the same data.</p>

<h3 id="cost-estimate">cost estimate</h3>

<p>disk I/o and CPU resources.</p>

<p>there are many default values for each operation. And they are defined based on the hardware. They can be updated via the tablespace level.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define DEFAULT_SEQ_PAGE_COST  1.0
#define DEFAULT_RANDOM_PAGE_COST  4.0
#define DEFAULT_CPU_TUPLE_COST 0.01
#define DEFAULT_CPU_INDEX_TUPLE_COST 0.005
#define DEFAULT_CPU_OPERATOR_COST  0.0025
#define DEFAULT_PARALLEL_TUPLE_COST 0.1
#define DEFAULT_PARALLEL_SETUP_COST  1000.0
</span>
<span class="cp">#define DEFAULT_EFFECTIVE_CACHE_SIZE  524288   </span><span class="cm">/* measured in pages */</span><span class="cp">
</span></code></pre></div></div>

<p>i/o cost = cost of single page * number of page to read</p>

<p>The planner will not consider parallel execution at all if the estimated volume of heap data to be read does not exceed the 8MB <strong>min_parallel_table_scan_size</strong> value.</p>

<p>Not all queries can be parallelized.</p>

<ul>
  <li>Query which modified or locked data UPDATE, DELETE, SELECT FOR UPDATE, and the like.</li>
  <li>Queries that can be paused. It applies to queries run within cursors, including FOR loops in PL/pgSQL</li>
  <li>Queries that call PARALLEL UNSAFE functions. By default, these are all user-defined functions and a few standard ones.</li>
  <li>Queries within functions if these functions are called from a parallelized query (to avoid recursive growth of the number of workers).</li>
</ul>

<h1 id="index-access-methods">Index Access Methods</h1>

<p>PostgreSQL supports six built-in index access methods: btree, hash, gist, gin sexiest, brin</p>

<p>Tuples in Postgresql are referred to by six-byte tuple IDs. TIDS</p>

<p>Data amount <strong>vs</strong> scan methods:</p>

<ul>
  <li>Select a large amount of data =&gt; sequential scan</li>
  <li>Select a small amount of data =&gt; index scan</li>
  <li>Select the mid-level amount of data =&gt; bitmap scan</li>
</ul>

<h1 id="index-scans">Index scans</h1>

<h2 id="index-only-scan">index-only scan</h2>

<p>the cost = estimated costs of index access operations and heap page reads.</p>

<p>I/o estimation depends on both the <strong>index scan selectivity</strong> and the <strong>correlation</strong> between the <strong>physical order of tuples on disk a</strong>nd the <strong>order in which the access method returns their IDs.</strong></p>

<h2 id="bitmap-scan">Bitmap scan</h2>

<p>A Bitmap Index Scan is used to efficiently determine “where to look” in the table, and a Bitmap Heap Scan is used to actually “look” at the data and retrieve it.</p>

<p>Bitmap index scan is less dependent on the correlation.</p>

<h1 id="join-methods">Join methods</h1>

<p>Postgresql provides several join methods:</p>

<ul>
  <li>a nested loop join</li>
  <li>a hash join</li>
  <li>a merge join</li>
</ul>

<h2 id="nested-loop-joins">Nested Loop Joins</h2>

<p><strong>supports  (inner join + left outer join), not support right join and full join.</strong></p>

<p>Traverse the outer set, for each record, it checks the inner set to see if there are matches, and it checks the inner set many times.</p>

<p>Therefore, the efficiency of nested loop joins depends on several factors:</p>

<ul>
  <li>The cardinality of the outer set of rows.</li>
  <li>Availability of an access method that can efficiently fetch the needed rows of the inner set.</li>
  <li>Recurrent access to the same rows of the inner set.</li>
</ul>

<p>A SQL could execute it in this way:</p>

<ul>
  <li>Scan the inner set and save data into a materialized file, then reuse it many times.</li>
</ul>

<p>CE: Cartesian product is estimated at the product of cardinalities of the joined data sets</p>

<p>Cost:</p>

<ul>
  <li>start cost: sum of the child node’s start cost</li>
  <li>cost of fetching all rows in the outer set,</li>
  <li>the cost of a single retrieval of all the rows of the inner set</li>
  <li>the cost of processing each row to be returned</li>
</ul>

<p>if the inner set is repeatedly scanned with the same parameter values, it can cache those rows, (page 407). However, since the data is too large, it can edit the caching results.</p>

<h2 id="hash-joins">Hash Joins</h2>

<p>Supports any type of join.</p>

<p>Suitable if the table can be accommodated in RAM. If not, two passes will be applied.</p>

<p><strong>The smaller set is usually used as the inner one, as it results in a smaller hash table.</strong></p>

<p>In the first stage, it builds a hash table by pulling the whole inner set of rows from its child node.</p>

<ul>
  <li>columns references in the join condition are hash key, value is all queried fields of the inner set.</li>
</ul>

<p>In the second stage, it traverses the other table, computes the hash key, and searches.</p>

<p>Costs:</p>

<ul>
  <li>build hash table: total cost of fetching inner set, calculate the hash function, insert rows into a hashtable.</li>
  <li>fetching the outer set of rows.</li>
</ul>

<p>If the data is too large to fit into the memory, the inner set is divided into many files, one is in memory while others are inside the disk.
For the outer set, it first calculates the hash for each row key, and can directly decide which batch that row belongs to, if belongs to the current batch (the batch in memory), it performs join, otherwise, it waits for the second pass.</p>

<p>if some temp file is too large, it cannot fit well into the memory, So if the hash table being built turns out too big, the number of batches is increased (doubled) on the fly. Each batch is virtually split into two new ones: about half of the rows (assuming that the distribution is uniform) are left in the hash table, while the other half is saved into a new temporary file</p>

<p>In the case of non-uniform distribution, increasing the number of batches may not help. For example, if the key column contains the same value in all its rows, it will be placed into the same batch since the hash function will return the same value over and over again. Unfortunately, the hash table will continue growing in this case, regardless of the imposed restrictions.</p>

<p>In theory, this issue could be addressed by a multi-pass join, which would perform partial scans of the batch, but it is not supported.</p>

<p><strong>This problem is not solved yet?</strong></p>

<h2 id="merge-join">Merge Join</h2>

<p>The merge join algorithm can be used with any types of joins</p>

<p>sort data by join key and return results which are also sorted similarly.</p>

<p>If there is <strong>order by</strong>, merge sort is used mostly.</p>

<p>Merge join requires the input tables to be sorted on the join keys. If the tables are not already sorted, PostgreSQL will sort them before performing the merge join. This sorting operation is represented in the plan by the Sort node.
It only uses one pass over both data sets and does not take any additional memory. It uses two pointers to current rows.</p>

<p>PostgreSQL can decide to use to various sorting methods:  quicksort, external merge, top_N heapsort</p>

<ul>
  <li>If the data set to be sorted fits the 4MB work_mem chunk, the classic quicksort method is applied.</li>
  <li>If a data set needs to be sorted only <strong>partially</strong> (as defined by the LIMIT clause), the heapsort method can be applied.</li>
  <li>If the scan shows that the data set is too big to be sorted in memory, the sorting node switches over to external merge sorting: all rows are written into several pre-sorted files, and rows inside each file are sorted, but across various files are not sorted. 
Then it uses a merge sort algorithm to merge those files.</li>
</ul>

<h2 id="comparison">Comparison</h2>

<h3 id="the-nested-loop-join">The nested loop join</h3>

<ul>
  <li>does not have any prerequisites and can start returning the first rows of the result set right away</li>
  <li>It is the only join method that does not have to fully scan the inner set (as long as index access is available for it).</li>
  <li>These properties make the nested loop algorithm (combined with indexes) an ideal choice for short <strong>OLTP</strong> queries,which deal with rather small sets of rows.</li>
  <li>supports all join conditions</li>
</ul>

<p>However</p>

<ul>
  <li>Thus, the complexity of the nested loop algorithm often shows linear growth rather than quadratic one, even if with a high linear coefficient.</li>
</ul>

<h3 id="a-hash-join">A hash join</h3>

<ul>
  <li>only one pass over two data sets. works best on large data sets.</li>
  <li>Combined with sequential table scans,this algorithm is typically used for <strong>OLAP</strong> queries,which compute the result based on a large volume of data.</li>
  <li>However, if the response time is more important than throughput, a hash join is not the best choice: it will not start returning the resulting rows until the whole hash table is built</li>
  <li>response time in this context, we are referring to the time between sending a query and receiving the first row of the result set</li>
</ul>

<h3 id="merge-join-1">Merge Join</h3>

<ul>
  <li>A merge join can perfectly handle both short OLTP queries and long OLAP ones.</li>
  <li>An added bonus of a merge join is the equivalence of the inner and outer sets. The efficiency of both nested loop and hash joins is highly dependent on whether the planner can assign inner and outer sets correctly.</li>
</ul>



                <br>
          <br>
    <br>


<!--               <div class="post-author text-center">                       
	        <img src="/tech-notebook/img/" alt="'s photo" itemprop="image" class="post-avatar img-circle img-responsive"/>    
	    <h4>By <span itemprop="name" class="fn"><a href="/tech-notebook/about/" title="About " itemprop="url"></a></span></h4>
	    <div style="font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif; display:inline-block;font-size:.75em;"></div>
</div> -->
    <hr class="small">
 <div class="post-share text-center">
    <p class="light small">
        <h6>END OF POST</h6>
    </p>
    <ul class="social-mini">

    </ul>
</div>
                        

                        
                <br>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/tech-notebook/journal/211/" data-toggle="tooltip" data-placement="top" title="Efficient Memory Management for Large Language Model Serving with PagedAttention">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/tech-notebook/journal/213/" data-toggle="tooltip" data-placement="top" title="ALECE An Attention-based Learned Cardinality Estimator for SPJ Queries on Dynamic Workloads (Extended)">Next Post &rarr;</a>
                    </li>
                    
                </ul>

        </div>
    </div>
</article>

<br>

<hr class="medium">

            <div class="tags-wrap">
   <div class="tags">

  <div class="section-heading group" style="color: #fff; text-align: center; margin-top: 10px;">

    <h3>Tags Cloud</h3>

  </div>










  <div class="tag-list">
    
  </div>

</div>

<hr class="medium">

<div class="categories">

  <div class="section-heading group" style="color: #fff; text-align: center; margin-top: 10px;">

    <h3>Categories Cloud</h3>

  </div>

 









 <div class="category-list">
   
<a href="/tech-notebook/journal/category//">  </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/a-paper-note/"> A paper note </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/cmu-database/"> CMU database </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/coding/"> coding </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/devices/"> devices </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/distributed-database/"> distributed database </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/machine-learning-basic/"> machine learning basic </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/operation-system/"> operation system </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/practise/"> practise </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/programming-language/"> programming language </a> &nbsp;&nbsp;

  </div>

</div>

<hr class="medium">

<br>
<br>

       </div>


<!-- jQuery -->    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<!-- Custom Theme JavaScript -->
<script src="/tech-notebook/js/main.min.js "></script>
<!-- include image popups -->
<script src="/tech-notebook/js/jquery.magnific-popup.js"></script>

<script type="text/javascript">
      $(document).ready(function($) {
        $('a.popup').magnificPopup({
         type: 'image',
	  gallery:{
         enabled:true,
         navigateByImgClick: true,
         preload: [0,1] // Will preload 0 - before current, and 1 after the current image
       },
image: {
      titleSrc: function(item) {
              return item.el.attr('title') + '&nbsp;' + item.el.attr('data-caption');
            }
        }
          // other options
      });
});
    </script>

<script src="/tech-notebook/js/retina.min.js"></script>
<!-- include Masonry -->
<script src="/tech-notebook/js/isotope.pkgd.min.js"></script> 
<!-- include mousewheel plugins -->
<script src="/tech-notebook/js/jquery.mousewheel.min.js"></script>
<!-- include carousel plugins -->
<script src="/tech-notebook/js/jquery.tinycarousel.min.js"></script>
<!-- include svg line drawing plugin -->
<script src="/tech-notebook/js/jquery.lazylinepainter.min.js"></script>
<!-- include custom script -->
<script src="/tech-notebook/js/scripts.js"></script>
<!-- Modernizr -->
 <script src="/tech-notebook/js/modernizr.js"></script>

</body>
</html>






    <a href="javascript:void(0)" title="SEARCH" onclick="superSearch.toggle()" class="super-search-btn">
<span class="fa fa-search" style="font-size:1em; position:fixed; right: .75em; top: 1em; z-index: 2;"></span>
</a>
<div class="super-search" id="js-super-search">
<a href="javascript:void(0)" onclick="superSearch.toggle()" class="super-search__close-btn"">
<span class="fa fa-close" style="font-size:48px;"></span>
</a>
<input type="text" placeholder="Type here to search" class="super-search__input" id="js-super-search__input">
<ul class="super-search__results" id="js-super-search__results"></ul>
</div>



 <script src="/tech-notebook/js/super-search.js"></script>

<script>
superSearch({
    searchFile: '/tech-notebook/feed.xml',
    searchSelector: '#js-super-search', // CSS Selector for search container element.
    inputSelector: '#js-super-search__input', // CSS selector for <input>
    resultsSelector: '#js-super-search__results' // CSS selector for results container
});
</script>

    
        <div class="row"  style="background-color: #530720; padding-bottom: 40px; margin-top: 50px; margin-bottom: 80px;">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

      <center><h4><p>It's the niceties that make the difference fate gives us the hand, and we play the cards.</h4></center>


<!--<form style="padding:3px;text-align:center;font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:12px;" action="https://tinyletter.com/photorgasms" method="post" target="popupwindow" onsubmit="window.open('https://tinyletter.com/yourproject', 'popupwindow', 'scrollbars=yes,width=800,height=600');return true"><input type="text" placeholder="Enter your email address"  style="width:200px;height:30px;border:0;background-color:#5A0F28;color:#dddddd;outline:0;padding-left:12px;" name="email" id="tlemail" />&nbsp; &nbsp; <input type="submit" value="Get notified!" style="background-color:#470118;color:#dddddd;height:30px;border:0;" /></form>-->
            </div>
        </div>
     
<style type="text/css">
        .tlemail::-webkit-input-placeholder {
   color: rgba(255,255,255,.45);
}
       .tlemail:-moz-placeholder { /* Firefox 18- */
   color: rgba(255,255,255,.45);  
}

      .tlemail::-moz-placeholder {  /* Firefox 19+ */
   color: rgba(255,255,255,.45);  
}

      .tlemail:-ms-input-placeholder {  
   color: rgba(255,255,255,.45);  
}
    </style>


    <!-- Footer -->
<footer>
<div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

                <ul class="list-inline text-center">

<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://facebook.com/" data-toggle="tooltip" title="Facebook">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://twitter.com/" data-toggle="tooltip" title="Twiiter">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://instagram.com/" data-toggle="tooltip" title="Instagram">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://flickr.com/photos/" data-toggle="tooltip" title="Flickr">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-flickr fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="http://.deviantart.com">-->
<!--                            <span class="fa-stack fa-lg" data-toggle="tooltip" title="Deviantart">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-deviantart fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
                    
                    <li>
                        <a href="https://github.com/NLGithubWP/tech-notebook" data-toggle="tooltip" title="Github">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
<!--            <li>-->
<!--    <a href="mailto:" data-toggle="tooltip" target="_blank" title="Email">-->
<!--                       <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>-->
<!--</span>-->
<!--          </a> </li>-->

<!--         <li>-->
<!--                        <a href="/tech-notebook/feed.xml" data-toggle="tooltip" title="Feed">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
                </ul>
                <p class="copyright text-muted">Copyright &copy; NoteBook 2025</p>
<center><h6><p>Powered by <a href="https://github.com/jekyll/">Jekyll</a>.</p></h6></center>
            </div>
        </div>
    </div>
</footer>


   <script>
//** jQuery Scroll to Top Control script- (c) 
//** v1.1 (April 7th, 10')
//** 1) Adds ability to scroll to an absolute position (from top of page) or specific element on the page instead.
//** 2) Fixes scroll animation not working in Opera. 
var scrolltotop={
//startline: Integer. Number of pixels from top of doc scrollbar is scrolled before showing control
//scrollto: Keyword (Integer, or "Scroll_to_Element_ID"). How far to scroll document up when control is clicked on (0=top).
setting: {startline:100, scrollto: 0, scrollduration:1000, fadeduration:[500, 100]},
controlHTML: '<img src="https://cloud.githubusercontent.com/assets/14811095/13691821/88412468-e744-11e5-8bb5-94340afd92e7.png" style="filter:alpha(opacity=100); -moz-opacity:1;"/>', //HTML for control, which is auto wrapped in DIV w/ ID="topcontrol"
controlattrs: {offsetx:35, offsety:60}, //offset of control relative to right/ bottom of window corner
anchorkeyword: '#top', //Enter href value of HTML anchors on the page that should also act as "Scroll Up" links
state: {isvisible:false, shouldvisible:false},
scrollup:function(){
if (!this.cssfixedsupport) //if control is positioned using JavaScript
this.$control.css({opacity:0}) //hide control immediately after clicking it
var dest=isNaN(this.setting.scrollto)? this.setting.scrollto : parseInt(this.setting.scrollto)
if (typeof dest=="string" && jQuery('#'+dest).length==1) //check element set by string exists
dest=jQuery('#'+dest).offset().top
else
dest=0
this.$body.animate({scrollTop: dest}, this.setting.scrollduration);
},
keepfixed:function(){
var $window=jQuery(window)
var controlx=$window.scrollLeft() + $window.width() - this.$control.width() - this.controlattrs.offsetx
var controly=$window.scrollTop() + $window.height() - this.$control.height() - this.controlattrs.offsety
this.$control.css({left:controlx+'px', top:controly+'px'})

},

togglecontrol:function(){
var scrolltop=jQuery(window).scrollTop()
if (!this.cssfixedsupport)
this.keepfixed()
this.state.shouldvisible=(scrolltop>=this.setting.startline)? true : false
if (this.state.shouldvisible && !this.state.isvisible){
this.$control.stop().animate({opacity:1}, this.setting.fadeduration[0])
this.state.isvisible=true
}
else if (this.state.shouldvisible==false && this.state.isvisible){
this.$control.stop().animate({opacity:0}, this.setting.fadeduration[1])
this.state.isvisible=false
}

},
init:function(){
jQuery(document).ready(function($){
var mainobj=scrolltotop
var iebrws=document.all

mainobj.cssfixedsupport=!iebrws || iebrws && document.compatMode=="CSS1Compat" && window.XMLHttpRequest //not IE or IE7+ browsers in standards mode
mainobj.$body=(window.opera)? (document.compatMode=="CSS1Compat"? $('html') : $('body')) : $('html,body')
mainobj.$control=$('<div id="topcontrol">'+mainobj.controlHTML+'</div>')
.css({position:mainobj.cssfixedsupport? 'fixed' : 'absolute', bottom:mainobj.controlattrs.offsety, right:mainobj.controlattrs.offsetx, opacity:0, cursor:'pointer'})
.attr({title:'Scroll To Top'})
.click(function(){mainobj.scrollup(); return false})
.appendTo('body')

if (document.all && !window.XMLHttpRequest && mainobj.$control.text()!='') //loose check for IE6 and below, plus whether control contains any text
mainobj.$control.css({width:mainobj.$control.width()}) //IE6- seems to require an explicit width on a DIV containing text
mainobj.togglecontrol()

$('a[href="' + mainobj.anchorkeyword +'"]').click(function(){
mainobj.scrollup()

return false
})

$(window).bind('scroll resize', function(e){

mainobj.togglecontrol()

})

})

}

}

scrolltotop.init()
</script>  

</body>

</html>
