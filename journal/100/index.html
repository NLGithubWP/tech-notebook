<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link media="all" rel="stylesheet" type="text/css" href="https://nlgithubwp.github.io/css/pygments.css" />
   <meta property="og:url" content="https://nlgithubwp.github.io/journal/100/" />
   <link rel="canonical" href="https://nlgithubwp.github.io/journal/100/" />


  <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
<link rel="icon" href="/tech-notebook/favicon.ico?" type="image/x-icon">

    <meta name="description" content="It's the niceties that make the difference fate gives us the hand, and we play the cards.">

    <title>Algorand-blog2 - NoteBook</title>

    <link rel="canonical" href="https://nlgithubwp.github.io/tech-notebook/journal/100/">

<!-- CSS -->
	
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/tech-notebook/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/tech-notebook/css/main.css">
    <link rel="stylesheet" href="/tech-notebook/css/galleries.css">
     <link rel="stylesheet" href="/tech-notebook/css/super-search.css">
    <link rel="stylesheet" href="/tech-notebook/css/magnificpopup.css">
    <link rel="stylesheet" href="/tech-notebook/css/pygments.css">

    <!-- Custom Fonts -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Josefin+Sans:400,600&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->


</head>


<head>

</head>

<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top" style="margin-right:1em; z-index: 1;">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <i class="fa fa-bars fa-lg"></i>
            </button>
            <a href="/tech-notebook/" title="HOME"><img src="/tech-notebook/img/logos/logo6.png" alt="logo" style="width:150px;cursor:pointer;margin-top:15px;"/></a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right" style="margin-right:1em; text-shadow: -.025em -.025em 0 rgba(0, 133, 161, 0.75), .025em -.025em 0 rgba(0, 133, 161, 0.75), -.025em .025em 0 rgba(0, 133, 161, 0.75), .025em .025em 0 rgba(0, 133, 161, 0.75);">
               
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/gallery/">GALLERY</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/journal/">JOURNAL</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/about/">ABOUT</a></li>
            
          
        
          
            
            
              <li><a href="https://nlgithubwp.github.io/tech-notebook/resume/">CV</a></li>
            
          
        
                            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>



    <html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        
        <meta name="viewport" content="width=device-width">

<link href="/tech-notebook/css/tags-wrap.css" rel="stylesheet" />
  
    </head>
    <body>
  



<article>
<!-- Post Header -->
<header class="intro-header" style="background-image: url('/tech-notebook/img/postcover/post02.jpg')">
    <div class="container">
        <div class="row">
            <div class="post-heading">
                    <h1 style="color: #acd578;">Algorand-blog2</h1>
                    
                    <span class="meta">Posted on November 21, 2022</span>

<span class="time-tag-categ" style="font-size:.7em;background-color: rgba(128, 128, 128, 0.45);">


<i class="fa fa-clock-o"></i>&nbsp;
37 minute read



 


  
   &sim; Filed in <i class="fa fa-briefcase"></i>&nbsp;:&nbsp;<a href="/tech-notebook/journal/category/A paper note/" data-toggle="tooltip" title="Other posts filed in A paper note category" rel="tag">A paper note</a>    
                    
   </span>

            </div>
        </div>
    </div>
</header>

<!-- Post Content -->

    <div class="container">
        <div class="row">
            

             <p>[TOC]</p>

<h2 id="what-is-algorand">What is Algorand?</h2>

<p><em>Algorand</em> is a digital currency and transaction platform that implements a new consensus algorithm that aims to solve blockchain’s scalability issues by <em>eliminating mining</em> and aims for strong decentralization by avoiding subjective influences in all choices. Algorand confirms transactions with latencies of <em>approximately a minute</em> even while scaling to many users, and ensures nearly instant recovery from any potential network partitions. Thus, there is <em>negligible possibility of forking</em> even in asynchronous environments. Algorand implements a new protocol termed [<strong>BA</strong><em>](#ba), which is a Byzantine Agreement protocol built on <a href="#cryptographic-sortition"><strong>cryptographic sortition</strong></a> which uses Verifiable Random Functions (<code class="language-plaintext highlighter-rouge">VRFs</code>) that together ensure high user security. The concept of Algorand was initially constructed by *Silvio Micali</em>, an MIT computer scientist who has previously earned the Turing Award and Godel Prize. The development of Algorand’s consensus protocol implements a multitude of novel concepts backed by rigorous proofs that he has adapted from previous work by himself and others. If you’d like, you can take a moment to check out <a href="https://www.algorand.com/">Algorand’s official website</a>.</p>

<p>Now you must be wondering, that sounds great but how does Algorand achieve all this? Keep reading on!</p>

<h2 id="algorands-consensus-protocol">Algorand’s Consensus Protocol</h2>
<p>The Algorand consensus protocol, as with many other consensus protocols, is built on a P2P network that relies on communication through <code class="language-plaintext highlighter-rouge">gossiping</code> (AKA broadcasting) information to the entire network to ensure a shared state. The consensus protocol consists of <code class="language-plaintext highlighter-rouge">rounds</code>, with each <code class="language-plaintext highlighter-rouge">round</code> being the period in which a new block is proposed and agreed upon to append to the blockchain. The consensus protocol consists of two primary parts - firstly, selected <code class="language-plaintext highlighter-rouge">block proposers</code> propose blocks to the network, and secondly, selected <code class="language-plaintext highlighter-rouge">committee members</code> perform <code class="language-plaintext highlighter-rouge">BA* consensus</code> on the highest priority block while it is propagating through the network. After a block has been agreed upon, it becomes appended to the blockchain. Algorand uses algorithms that ensure only a very limited amount of users in the entire network become block proposers and committee members. By having a small amount of users acting for the entire network, Algorand is able to retain nearly consistent performance regardless of network scale.</p>

<h4 id="selection-of-proposers-and-committee-members">Selection of Proposers and Committee Members</h4>
<p>The Algorand consensus protocol ensures that in all parts of consensus, once a user has broadcasted their message to the network, they will not be required for the rest of the process and thus attacks against them will not affect the network. This is possible because of a procedure called <a href="#cryptographic-sortition"><strong>cryptographic sortition</strong></a> that ensures no one knows who is a committee member or proposer until the selected users have already broadcasted their message to be checked by other users in the network, and different users are chosen every time a new proposer or verification committee is required.</p>

<h4 id="proposing-a-block">Proposing a Block</h4>
<p><a href="#block-proposal"><strong>Block proposal</strong></a>, in short, ensures that a random but very small amount of users are selected from the entire network to propose blocks, weighted by their account balance and some randomness. The output of <code class="language-plaintext highlighter-rouge">cryptographic sortition</code> is used to calculate a <code class="language-plaintext highlighter-rouge">priority</code> hash that is used to compare block proposers and select who is the final proposer, as well as a <code class="language-plaintext highlighter-rouge">proof</code> that proves that they were truly a selected block proposer for that <code class="language-plaintext highlighter-rouge">round</code>. The proposer with the highest priority becomes the block proposer for each round. Now that we’ve covered the basics, we can get into the details of how each process works!</p>

<h4 id="agreement-on-a-block">Agreement on a Block</h4>
<p>The proposal process does not guarantee that every user receives the exact same highest priority block, thus to ensure safety, the next <code class="language-plaintext highlighter-rouge">Agreement</code> step is conducted after block proposals have been received. Every user performs <a href="#ba"><strong>BA</strong>*</a> with their highest priority block. <code class="language-plaintext highlighter-rouge">BA*</code> executes in multiple <code class="language-plaintext highlighter-rouge">steps</code>, each beginning with <code class="language-plaintext highlighter-rouge">cryptographic sortition</code> to select verifiers. This sortition algorithm allows a user to determine if they are a committee member for a given <code class="language-plaintext highlighter-rouge">step</code>, and if so, broadcast their verification of the block to the network alongside their <code class="language-plaintext highlighter-rouge">proof</code> that they are a committee member. Each <code class="language-plaintext highlighter-rouge">step</code> repeats this process, and this process continues until users have received enough votes for consensus the next block. The next block will either be a <code class="language-plaintext highlighter-rouge">proposed block</code>, or it will be an <code class="language-plaintext highlighter-rouge">empty block</code> in the case that agreement could not be reached once the round reaches a <code class="language-plaintext highlighter-rouge">TIMEOUT</code>. This ensures that the network will not hang, and a decision can always be made.</p>

<h5 id="algorand-protocol-diagram">Algorand Protocol Diagram</h5>
<p>Algorand’s protocol procedures can be portrayed in a directed graph as follows. It may be helpful to refer back to this diagram as we go through each part of the process later on!</p>

<p><img src="../../img/a_img_store/algorand_protocol.png" alt="image-20221117185619521" /></p>

<h5 id="implementation-parameters">Implementation Parameters</h5>
<p>Additionally, Algorand defines several parameter values used in their implementation as follows. These values will be referenced later on.</p>

<p><img src="../../img/a_img_store/implementation_params.png" alt="image-20221117185619521" /></p>

<h2 id="cryptographic-sortition">Cryptographic Sortition</h2>
<h4 id="in-short">In Short</h4>
<p>The goal of <code class="language-plaintext highlighter-rouge">cryptographic sortition</code> is to find a small group of users in the network such that they can be easily verified by any other user of their status as verifier or proposer using the <code class="language-plaintext highlighter-rouge">proofs</code> outputted by the algorithm. The algorithm ensures that only a small amount of users are selected based on the <code class="language-plaintext highlighter-rouge">weight</code> of each user that depends on their account balance, alongside a varying degree of randomness such that the output cannot be determined ahead of time by some attacker. This process is completely objective, meaning that the entire process is conducted purely through computation, thus human intentions are unable to sway the process.</p>

<p>Sortition ensures the security of the users selected as essentially, no one knows who is a proposer or verifier until they have already broadcasted their work to the network, and then anyone can verify that their proposer or verifier status is true as claimed. This is enabled through an algorithm called a Verifiable Random Function, or <code class="language-plaintext highlighter-rouge">VRF</code> which outputs a <code class="language-plaintext highlighter-rouge">proof</code> that anyone can verify with a user’s <code class="language-plaintext highlighter-rouge">publicKey</code>. Additionally, no one knows if they themselves are a verifier or proposer until they have the <code class="language-plaintext highlighter-rouge">seed</code> necessary to determine their status.</p>

<p>The entire process itself executes as such: when a user runs sortition, they calculate a VRF <code class="language-plaintext highlighter-rouge">input</code> based on the <code class="language-plaintext highlighter-rouge">seed</code> stored in some specified previous block and a <code class="language-plaintext highlighter-rouge">role</code> value that changes depending on which part of the process they are on, then run a <code class="language-plaintext highlighter-rouge">VRF</code> using that input and their private key to calculate a verifiable <code class="language-plaintext highlighter-rouge">proof</code> and <code class="language-plaintext highlighter-rouge">hash</code>. Finally, they determine their selection status through a value called <code class="language-plaintext highlighter-rouge">sub users</code>, which they calculate using their <code class="language-plaintext highlighter-rouge">hash</code> and account balance as a <code class="language-plaintext highlighter-rouge">weight</code> against the entire network’s currency. When this <code class="language-plaintext highlighter-rouge">subUser</code> value is above 0, it means they have been selected to participate as a block proposer or committee verifier. Anyone can then validate a user’s <code class="language-plaintext highlighter-rouge">VRF</code> outputs and determine their <code class="language-plaintext highlighter-rouge">subUser</code> count.</p>

<h4 id="the-details---vrf-and-user-selection">The Details - VRF and User Selection</h4>
<p>Algorand implements cryptographic sortition through verifiable random functions, or <code class="language-plaintext highlighter-rouge">VRFs</code>. The objective of a <code class="language-plaintext highlighter-rouge">VRF</code> is to allow a user to generate their own proof and a hash to assist in determining their status, then allow any other user to verify it later.</p>

<p>A <code class="language-plaintext highlighter-rouge">VRF</code> produces a <code class="language-plaintext highlighter-rouge">proof</code> and <code class="language-plaintext highlighter-rouge">hash</code> using your <code class="language-plaintext highlighter-rouge">privateKey</code> and a random <code class="language-plaintext highlighter-rouge">input</code>. This <code class="language-plaintext highlighter-rouge">hash</code> appears completely random to any user who does not know their <code class="language-plaintext highlighter-rouge">privateKey</code>, and is used to determine proposer or committee verifier status. The <code class="language-plaintext highlighter-rouge">proof</code> allows any user to verify that, given the user’s <code class="language-plaintext highlighter-rouge">publicKey</code>, the <code class="language-plaintext highlighter-rouge">hash</code> does indeed correspond to the <code class="language-plaintext highlighter-rouge">input</code> used to generate their proof in the current step, and thus verifies whether the user is indeed a proposer or verifier for the specified step. For more information on how exactly VRF works, <a href="https://www.cs.bu.edu/~goldbe/projects/vrf">check out Sharon Goldberg’s work</a>!</p>

<p>In the process of proposer and verifier selection, the value of <code class="language-plaintext highlighter-rouge">input</code> in each step is the combination of two values through concatenation: <code class="language-plaintext highlighter-rouge">seed</code> and <code class="language-plaintext highlighter-rouge">role</code>. The value of the random <code class="language-plaintext highlighter-rouge">seed</code> is refreshed after every seed refresh interval (<code class="language-plaintext highlighter-rouge">R</code>) ends. An interval is a predetermined amount of <code class="language-plaintext highlighter-rouge">rounds</code> (a round is each block selection period and its value is equal to the block number), and the value of the <code class="language-plaintext highlighter-rouge">role</code> is recalculated for every <code class="language-plaintext highlighter-rouge">step</code>, thus ensuring that <code class="language-plaintext highlighter-rouge">input</code> is never the same. Since this value is a major factor in determining who is selected, this implies selected users are different every time cryptographic sortition is conducted.</p>

<ul>
  <li><strong>VRF Input:</strong> <code>input := seed||role</code></li>
  <li><strong>Hash &amp; Proof:</strong> <code>hash, proof := VRF(privateKey, input)</code></li>
</ul>

<p>Every <code class="language-plaintext highlighter-rouge">R</code> rounds, a seed refresh interval ends and a new seed is determined for the next interval. This value <code class="language-plaintext highlighter-rouge">R</code> is defined to be <a href="#implementation-parameters"><em>1000</em></a> rounds in Algorand’s implementation. In each round, the <code class="language-plaintext highlighter-rouge">seed</code> is obtained from the block at the start of the current seed refresh interval. The block proposer of each round-1 calculates the <code>seed<sub>round</sub></code> that will be used for the next round’s sortition calls by taking the <code class="language-plaintext highlighter-rouge">VRF</code> of their <code class="language-plaintext highlighter-rouge">privateKey</code> and an <code class="language-plaintext highlighter-rouge">input</code> determined by the current interval’s <code class="language-plaintext highlighter-rouge">seed</code> concatenated with the <code class="language-plaintext highlighter-rouge">round</code> number, then storing it in the block they propose along with the VRF proof. If the current block is an <code class="language-plaintext highlighter-rouge">empty block</code>, the next round’s seed will instead be calculated by each user themselves via taking a cryptographic hash function of the <code class="language-plaintext highlighter-rouge">input</code>, then storing it in the block.</p>

<ul>
  <li><strong>Block Proposer Seed Selection:</strong> <code>seed<sub>round</sub>, proof := VRF(privateKey, seed||round)</code></li>
  <li><strong>Empty Block Seed Selection:</strong> <code>seed<sub>round</sub> := HashFunc(seed||round)</code></li>
</ul>

<p>Now that we have obtained a <code class="language-plaintext highlighter-rouge">hash</code> and <code class="language-plaintext highlighter-rouge">proof</code>, we can determine how likely someone is to be selected. During sortition, every user’s <code class="language-plaintext highlighter-rouge">weight</code> is equal to their account balance. Algorand gives the term <code class="language-plaintext highlighter-rouge">subUser</code> to represent each unit of currency in the network, thus if a user has <code class="language-plaintext highlighter-rouge">x</code> units of currency, they have <code class="language-plaintext highlighter-rouge">x</code> <code class="language-plaintext highlighter-rouge">subUsers</code>. The <code class="language-plaintext highlighter-rouge">probability</code> that any <code class="language-plaintext highlighter-rouge">subUser</code> being chosen is equivalent to the count of <code class="language-plaintext highlighter-rouge">expectedUsers</code> we wish to choose for a step divided by the <code class="language-plaintext highlighter-rouge">totalCurrency</code> in the entire network. Note that user <code class="language-plaintext highlighter-rouge">weights</code> and network <code class="language-plaintext highlighter-rouge">totalCurrency</code> are obtained from the time of the first block in the current seed refresh interval. Then, on an interval from 0 (inclusive) to 1 (not inclusive), we divide it into <code class="language-plaintext highlighter-rouge">x+1</code> intervals based on binomial distribution (in a way that ensures that the resulting divisions are proportioned appropriately to select the <code class="language-plaintext highlighter-rouge">expectedUsers</code> from the network), with 0 being the largest range and each section after that decreasing in range. You can see an example of such division in the following image:</p>

<p><img src="../../img/a_img_store/subusers.png" alt="image-20221117185619521" /></p>

<p>Then we calculate some value <code>c = <sup>hash</sup>/<sub>2<sup>hash-length</sup></sub></code>. This ensures that the value <code class="language-plaintext highlighter-rouge">c</code> falls in the interval <code class="language-plaintext highlighter-rouge">[0,1)</code> as seen in the diagram above. We then take whatever <code class="language-plaintext highlighter-rouge">subUser</code> interval <code class="language-plaintext highlighter-rouge">c</code> falls into, and this becomes the <code class="language-plaintext highlighter-rouge">subUser</code> count for the user and can be thought about as the number of times they may participate. This count alongside a user’s <code class="language-plaintext highlighter-rouge">hash</code> goes into determining their priority of selection for block proposer, and in the case of committee selection, the number of votes they may cast. Further details of this will be explained later on. This subUser count can be verified by anyone after verifying their VRF proof and running the same subUser calculations based on the user’s account balance (weight).</p>

<p>Cryptographic sortition consists of two main procedures to create and validate proofs. Firstly, a user running <a href="#sortition-procedure"><em>Sortition</em></a>  generates a <code class="language-plaintext highlighter-rouge">VRF</code> proof and then calculates a <code class="language-plaintext highlighter-rouge">subUser</code> count for themselves. Secondly, <a href="#verifysort-procedure"><em>VerifySort</em></a> can be run by any user receiving messages broadcasted from potential proposers and verifiers. This verification takes in the data received from messages with, verifies the <code class="language-plaintext highlighter-rouge">VRF</code> of the message, and uses the same calculations as used in <a href="#sortition-procedure"><em>Sortition</em></a>  to output the <code class="language-plaintext highlighter-rouge">subUser</code> count associated with that message if the <code class="language-plaintext highlighter-rouge">VRF</code> verification is valid.</p>

<p>This process is outlined as such in the following algorithms for <a href="#sortition-procedure"><em>Sortition</em></a> and <a href="#verifysort-procedure"><em>VerifySort</em></a>:</p>

<h5 id="sortition-procedure">Sortition Procedure</h5>
<p><img src="../../img/a_img_store/alg_sortition.png" alt="image-20221117185619521" /></p>

<h5 id="verifysort-procedure">VerifySort Procedure</h5>
<p><img src="../../img/a_img_store/alg_verifysort.png" alt="image-20221117185619521" /></p>

<h2 id="block-proposal">Block Proposal</h2>
<h4 id="in-short-1">In Short</h4>
<p>At first, users will collect a pool of transactions they have heard from the P2P network. Then, during block proposal, every user runs <a href="#cryptographic-sortition"><strong>cryptographic sortition</strong></a> to determine how many <code class="language-plaintext highlighter-rouge">subUsers</code> (or attempts) they have to obtain their highest <code class="language-plaintext highlighter-rouge">priority</code>. If a user finds that they are a block proposer (meaning their subUser count is greater than 0), they will package their transactions into a <code class="language-plaintext highlighter-rouge">block</code> and broadcast it alongside their <code class="language-plaintext highlighter-rouge">proof</code> and <code class="language-plaintext highlighter-rouge">subUser</code> count. The network will then attempt to find the block with the highest priority to begin verification.</p>

<h4 id="the-details---proposer-and-block-selection">The Details - Proposer and Block Selection</h4>
<p>First, at the start of each round, every user runs <code class="language-plaintext highlighter-rouge">cryptographic sortition</code> to calculate their <code class="language-plaintext highlighter-rouge">subUser</code> count. This amount indicates how many times they can run a calculation to determine their priority. When running cryptographic sortition, some value <code>expectedUsers<sub>proposer</sub></code> greater than 1. Algorand specifies that choosing <code>expectedUsers<sub>proposer</sub>=</code><a href="#implementation-parameters"><em>26</em></a> allows for a reasonable amount of selected users ranging from at least 1 to no more than 70 with an extremely high probability of 1−10<sup>-11</sup>. The proof for these values can be found in <em>Appendix B.1</em> in the <a href="https://people.csail.mit.edu/nickolai/papers/gilad-algorand-eprint.pdf">technical report</a>.</p>

<p><code class="language-plaintext highlighter-rouge">Priority</code> is calculated as follows: given a user’s <code class="language-plaintext highlighter-rouge">subUser</code> count, for each <code class="language-plaintext highlighter-rouge">index</code> 1, 2, … up to the <code class="language-plaintext highlighter-rouge">subUser</code> count, the user takes their VRF <code class="language-plaintext highlighter-rouge">hash</code> from sortition and concatenates it with the <code class="language-plaintext highlighter-rouge">index</code>. Then they use a hash function to hash this resulting <code class="language-plaintext highlighter-rouge">priority</code>. Thus, the more subUsers a user has, the more times they can attempt hashing and generate a higher priority. After running this process for all subUsers, the highest <code class="language-plaintext highlighter-rouge">priority</code> is chosen as their block’s priority.</p>

<ul>
  <li><strong>Potential Priority Calculation:</strong> <code>priority := HashFunc(hash||index)</code></li>
</ul>

<p>The user then <code class="language-plaintext highlighter-rouge">gossips</code> two messages to the network, one with their <code class="language-plaintext highlighter-rouge">priority</code> and <code class="language-plaintext highlighter-rouge">proof</code>, the other with their <code class="language-plaintext highlighter-rouge">block</code> which also includes their <code class="language-plaintext highlighter-rouge">hash</code> and <code class="language-plaintext highlighter-rouge">proof</code>. The reason for this design is so that the first message is smaller (~200 bytes) and can propagate faster than the second message, thus users can determine the highest priority early and discard all other blocks they receive that are lower than it.</p>

<p>Users will wait certain time intervals before determining a highest priority block from messages they have received. Experimentally, Algorand estimates an approximate time of 10 seconds after the previous round has ended to ensure that most users have completed the last round and enough blocks have been gossiped. This value is determined by adding the time to gossip a sortition proof (<code>time<sub>priority</sub>=</code><a href="#implementation-parameters"><em>5 seconds</em></a>) with the estimated variance of BA* completion time (<code>time<sub>stepvar</sub>=</code><a href="#implementation-parameters"><em>5 seconds</em></a>). Then, once the user determines the highest priority <code class="language-plaintext highlighter-rouge">block</code>, they move on to <a href="#BA"><strong>BA</strong><em>](#BA). If the user has not received any results for approximately a minute after this initial waiting period, they will instead proceed to [<strong>BA</strong></em></a> using an <code class="language-plaintext highlighter-rouge">empty block</code>. The time of a minute is chosen such that it does not take excessively long to decide on a block and slow the network.</p>

<p>This block proposal protocol cannot be solely relied upon to produce a single output block, as propagation in the network may result in certain users receiving a different highest priority block. Thus, the next part of the protocol, <a href="#BA"><strong>BA</strong>*</a>, is required to achieve an agreement on a single output.</p>

<h2 id="ba">BA*</h2>
<h4 id="in-short-2">In Short</h4>
<p><code class="language-plaintext highlighter-rouge">BA*</code> is a type of Byzantine Agreement protocol that attempts to achieve consensus on a block even if certain components are unreliable or malicious. In Algorand, <code class="language-plaintext highlighter-rouge">BA*</code> has two main phases, <code class="language-plaintext highlighter-rouge">Reduction</code> and <code class="language-plaintext highlighter-rouge">BinaryBA*</code>. In the <code class="language-plaintext highlighter-rouge">Reduction</code> phase, the consensus problem is reduced from potentially many blocks down to exactly two options - either a proposed block or an empty block. <code class="language-plaintext highlighter-rouge">BinaryBA</code> then takes these two choices and the network agrees on one or the other. After this, a final vote count is performed and if the votes are above a <code class="language-plaintext highlighter-rouge">threshold</code>, the network will produce a <code class="language-plaintext highlighter-rouge">Final Consensus</code> after confirming there are no other blocks that have also reached consensus. Otherwise, it will produce a <code class="language-plaintext highlighter-rouge">Tentative Consensus</code> in the case that BA* cannot ensure there are no other blocks to check for agreement. In a strongly synchronous network, this <code class="language-plaintext highlighter-rouge">Tentative Consensus</code> will be amended to be final once <code class="language-plaintext highlighter-rouge">Final Consensus</code> is reached on some block that comes some number of rounds after it, thus verifying all blocks before it. Otherwise, in a weakly synchronous network due to an attacker controlling the entire network, there is a possibility of forking, and the network will recover during a periodic recovery process by resolving forks through BA* consensus on the forks themselves, and one will be agreed upon once strong synchrony is restored. It is notable that this second scenario is highly inprobable, with a chance of 10<sup>-12</sup> or 10<sup>-18</sup> as described in Algorand’s <a href="https://arxiv.org/pdf/1607.01341.pdf">theoretical paper</a>.</p>

<p>The two phases consist of multiple <code class="language-plaintext highlighter-rouge">steps</code>, each of which will run <a href="#cryptographic-sortition"><strong>cryptographic sortition</strong></a> to select a new and unique verifier committee for voting. The repeated selection of different committees is to ensure chosen verifiers can perform their role without being compromised. In every step, committee members all broadcast their <code class="language-plaintext highlighter-rouge">vote</code> for some value they have received from the network, then all the votes are counted. Once a user receives over some <code class="language-plaintext highlighter-rouge">threshold</code> amount of votes for some value, they will broadcast that same vote to the network in the next step if they become a committee member in that step.</p>

<p>Voting is performed on <code class="language-plaintext highlighter-rouge">values</code> set to the hashes of blocks rather than the blocks themselves. This ensures a faster and more efficient propagation through the network. Any user who is participating in the network can receive these vote messages and process them to determine the status of consensus. If any value being voted on achieves more <code class="language-plaintext highlighter-rouge">votes</code> than <code>threshold=T\*expectedUsers</code>, that value is returned as the value for that step. <code class="language-plaintext highlighter-rouge">T</code> is some value greater than <sup>2</sup>/<sub>3</sub>, and <code class="language-plaintext highlighter-rouge">T</code> and <code>expectedUsers</code> are determined through a calculation that finds the minimal optimal committee size. If at any point, the processes runs out of time before any value receives sufficient votes, the system reaches a defined <code class="language-plaintext highlighter-rouge">TIMEOUT</code> state, and their vote for the next step will be determined accordingly based on the step they are on.</p>

<h4 id="the-details---voting-and-consensus">The Details - Voting and Consensus</h4>

<h5 id="ba-procedure">BA* Procedure</h5>
<p>The BA* procedure occurs as follows. First it undergoes <code class="language-plaintext highlighter-rouge">Reduction</code> to bring votes down to two possible hashes, then runs through <code class="language-plaintext highlighter-rouge">BinaryBA</code> to finalize consensus on a single block for <code class="language-plaintext highlighter-rouge">Tentative</code> or <code class="language-plaintext highlighter-rouge">Final Consensus</code>. Note that <code class="language-plaintext highlighter-rouge">context</code> refers to a snapshot of the current chain state. The individual parts of this procedure will be discussed in detail shortly.</p>

<p><img src="../../img/a_img_store/alg_bastar.png" alt="image-20221117185619521" /></p>

<h5 id="voting">Voting</h5>
<p><code class="language-plaintext highlighter-rouge">BA*</code> relies heavily on voting, which occurs as follows. A user runs the <a href="#committeevote-procedure"><em>CommitteeVote</em></a> procedure to check their verifier status and broadcast their votes. For a user to determine if they are selected for a certain <code class="language-plaintext highlighter-rouge">step</code>, they simply run <a href="#sortition-procedure"><em>Sortition</em></a>  using an <code class="language-plaintext highlighter-rouge">expectedUsers</code> count for each step and a <code class="language-plaintext highlighter-rouge">role</code> value obtained through the string <code class="language-plaintext highlighter-rouge">'committee'</code>, the <code class="language-plaintext highlighter-rouge">round</code>, and the current <code class="language-plaintext highlighter-rouge">step</code>. This ensures that the <code class="language-plaintext highlighter-rouge">role</code> changes every step, thus selecting a different committee. If a user’s <code class="language-plaintext highlighter-rouge">subUser</code> count is greater than 0, they broadcast their vote with their <code class="language-plaintext highlighter-rouge">publicKey</code> while signing their <code class="language-plaintext highlighter-rouge">proof</code>, <code class="language-plaintext highlighter-rouge">hash</code>, <code class="language-plaintext highlighter-rouge">round</code>, <code class="language-plaintext highlighter-rouge">value</code>, and the <code class="language-plaintext highlighter-rouge">lastBlockHash</code> of the chain they know of with their <code class="language-plaintext highlighter-rouge">privateKey</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">expectedUsers</code> for the voting committee is determined for the network beforehand, alongside a percentage <code class="language-plaintext highlighter-rouge">T</code> that results in an approximated minimal optimal committee size for a given fraction of honest users <code class="language-plaintext highlighter-rouge">h</code>. The <code class="language-plaintext highlighter-rouge">expectedUsers</code> is really referring to the number of <code class="language-plaintext highlighter-rouge">subUsers</code> expected to be selected, which in turn represents a number of expected <code class="language-plaintext highlighter-rouge">votes</code>. The following two conditions must be satisfied when determining these values, as shown below using some number of <code class="language-plaintext highlighter-rouge">good</code> and <code class="language-plaintext highlighter-rouge">bad</code> committee members:</p>

<ul>
  <li><strong>Condition 1:</strong> <code>good &gt; T*expectedUsers</code></li>
  <li><strong>Condition 2:</strong> <code><sup>1</sup>/<sub>2</sub>good + bad &lt; T*expectedUsers</code></li>
</ul>

<p>This is achieved by beginning with an arbitrarily high value of <code class="language-plaintext highlighter-rouge">expectedUsers</code>, and determining if there is a value <code>T&gt;<sup>2</sup>/<sub>3</sub></code> such that both conditions are satisfied. If so, the <code class="language-plaintext highlighter-rouge">expectedUsers</code> is decreased and the calculation is repeated until there is no such value <code class="language-plaintext highlighter-rouge">T</code>. This <code class="language-plaintext highlighter-rouge">expectedUsers</code> value is then used for sortition. The reason for requiring <sup>2</sup>/<sub>3</sub> votes is to ensure committee consensus even in the case of faulty committee members. The reasoning behind this is described by <a href="https://medium.com/loom-network/understanding-blockchain-fundamentals-part-1-byzantine-fault-tolerance-245f46fe8419">Byzantine fault tolerance</a>, which is the basis for BA<em>. Note that in the final step of BA</em>, a different and larger set of <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">expectedUsers</code> is used that ensures an overwhelming safety probability even when the network is in weak synchrony, as this is the crucial final step of consensus. The final values should be set such that there is high security even if the block proposer with the lowest priority is malicious. Algorand specifies that, for a fraction <code class="language-plaintext highlighter-rouge">h=</code><a href="#implementation-parameters"><em>80%</em></a> of honest users, a value of <code>expectedUsers<sub>step</sub>=</code><a href="#implementation-parameters"><em>2000</em></a> suffices for a <code>T<sub>step</sub></code> of <a href="#implementation-parameters"><em>68.5%</em></a> during every step (thus <code class="language-plaintext highlighter-rouge">threshold=1370</code>), and in the final step, <code>expectedUsers<sub>final</sub>=</code><a href="#implementation-parameters"><em>10000</em></a> <code class="language-plaintext highlighter-rouge">expectedUsers</code> suffices for a <code>T<sub>final</sub></code> of <a href="#implementation-parameters"><em>74%</em></a> (thus <code class="language-plaintext highlighter-rouge">threshold=7400</code>). The theoretical proofs and explanations behind these values can be found in <em>Appendix B.2</em> and <em>C.1</em> in the <a href="https://people.csail.mit.edu/nickolai/papers/gilad-algorand-eprint.pdf">technical report</a>.</p>

<p>Once votes are cast, a user receiving these vote <code class="language-plaintext highlighter-rouge">messages</code> can run <a href="#countvotes-procedure"><em>CountVotes</em></a> to validate and record each <code class="language-plaintext highlighter-rouge">message</code>. In this <a href="#countvotes-procedure"><em>CountVotes</em></a> procedure, the user will first validate a <code class="language-plaintext highlighter-rouge">message</code> through a procedure called <a href="#processmsg-procedure"><em>ProcessMsg</em></a> which achieves this by checking if the <code class="language-plaintext highlighter-rouge">signature</code> of the message data is true with the given <code class="language-plaintext highlighter-rouge">publicKey</code>, then checking if the <code class="language-plaintext highlighter-rouge">lastBlockHash</code> matches the hash of the user’s own <code class="language-plaintext highlighter-rouge">lastBlock</code> to ensure that it extends the chain, and finally running <a href="#verifysort-procedure"><em>VerifySort</em></a> to obtain the number of <code class="language-plaintext highlighter-rouge">subUsers</code> corresponding with the message data, and this <code class="language-plaintext highlighter-rouge">subUser</code> count becomes the number of <code class="language-plaintext highlighter-rouge">votes</code> that are cast for a <code class="language-plaintext highlighter-rouge">blockHash</code>. <em>Note that this usage of the sub user count is slightly different than the usage for determining block proposer priority.</em> After obtaining the votes output from <a href="#processmsg-procedure"><em>ProcessMsg</em></a>, a user will then add these votes to the total vote count for the corresponding value, while also recording the total vote count for every value they find. Finally, they will select whichever value first receives more than a <code class="language-plaintext highlighter-rouge">threshold</code> amount of votes, equal to <code class="language-plaintext highlighter-rouge">T*expectedUsers</code>. This threshold ensures that if any honest user determines a value, all other honest users will also return either the same <code class="language-plaintext highlighter-rouge">value</code> or they will <code class="language-plaintext highlighter-rouge">TIMEOUT</code> after a certain specified duration for each step. This duration is different depending on the step being performed.</p>

<p>In every step of <code class="language-plaintext highlighter-rouge">BA*</code>, this <a href="#committeevote-procedure"><em>CommitteeVote</em></a> and <a href="#countvotes-procedure"><em>CountVotes</em></a> process is conducted by every user as described during the voting process. Of course, even though every user runs the <a href="#committeevote-procedure"><em>CommitteeVote</em></a>, only those chosen will go through to broadcasting their votes.</p>

<h5 id="committeevote-procedure">CommitteeVote procedure</h5>
<p><img src="../../img/a_img_store/alg_committeevote.png" alt="image-20221117185619521" /></p>

<h5 id="countvotes-procedure">CountVotes procedure</h5>
<p><img src="../../img/a_img_store/alg_countvotes.png" alt="image-20221117185619521" /></p>

<h5 id="processmsg-procedure">ProcessMsg procedure</h5>
<p><img src="../../img/a_img_store/alg_processmsg.png" alt="image-20221117185619521" /></p>

<h5 id="reduction">Reduction</h5>
<p>The first phase of <code class="language-plaintext highlighter-rouge">BA*</code> is <a href="#reduction-procedure"><em>Reduction</em></a>, which occurs in two <code class="language-plaintext highlighter-rouge">steps</code>. The purpose of the first step is for committee members to broadcast their individual highest priority blocks, while the purpose of the second step is to determine and broadcast the most popular block output from the first step.</p>

<ol>
  <li>
    <p>In the first step, a new <a href="#committeevote-procedure"><em>CommitteeVote</em></a> is conducted (using a step equal to some value <code class="language-plaintext highlighter-rouge">REDUCTION_ONE</code>) where each member picks a <code class="language-plaintext highlighter-rouge">blockHash</code> out of the hashes they have seen based on highest priority, and then broadcasts their <code class="language-plaintext highlighter-rouge">votes</code> (AKA <code class="language-plaintext highlighter-rouge">subUser</code> count) alongside the <code class="language-plaintext highlighter-rouge">blockHash</code> to the network, as well as providing the necessary data to prove their status. Then, all users count vote <code class="language-plaintext highlighter-rouge">messages</code> received by running the <a href="#countvotes-procedure"><em>CountVotes</em></a> procedure as described in the <a href="#voting"><strong>Voting</strong></a> section earlier. The <code class="language-plaintext highlighter-rouge">TIMEOUT</code> duration they will wait for vote messages (if they do not find a hash that surpasses the <code class="language-plaintext highlighter-rouge">threshold</code> of votes) is equivalent to 1 minute and 20 seconds, calculated by adding the timeout for receiving the last block with the timeout for a single BA* step. These times are set to <code>time<sub>block</sub>=</code><a href="#implementation-parameters"><em>1 minute</em></a> and <code>time<sub>step</sub>=</code><a href="#implementation-parameters"><em>20 seconds</em></a> respectively in Algorand’s implementation.</p>
  </li>
  <li>
    <p>In the second step, a new <a href="#committeevote-procedure"><em>CommitteeVote</em></a> is conducted (using a step equal to some value <code class="language-plaintext highlighter-rouge">REDUCTION_TWO</code>) where members will determine the <code class="language-plaintext highlighter-rouge">blockHash</code> that first received enough votes from the first step to pass the <code class="language-plaintext highlighter-rouge">threshold</code>, and then <code class="language-plaintext highlighter-rouge">gossip</code> their <code class="language-plaintext highlighter-rouge">votes</code> for it to the network. Otherwise, if no hash surpasses the threshold after the <code class="language-plaintext highlighter-rouge">TIMEOUT</code> (set to <code>time<sub>step</sub>=</code><a href="#implementation-parameters"><em>20 seconds</em></a>), they will instead gossip their votes for an <code class="language-plaintext highlighter-rouge">emptyHash</code> which points to an <code class="language-plaintext highlighter-rouge">empty block</code> that stores only the current <code class="language-plaintext highlighter-rouge">round</code> and the <code class="language-plaintext highlighter-rouge">lastBlockHash</code>. Finally, users will listen for <code class="language-plaintext highlighter-rouge">messages</code> sent from this second step and count the votes and return to themselves the <code class="language-plaintext highlighter-rouge">blockHash</code> that first gets more <code class="language-plaintext highlighter-rouge">votes</code> than the <code class="language-plaintext highlighter-rouge">threshold</code>, otherwise return an <code class="language-plaintext highlighter-rouge">emptyHash</code> on <code class="language-plaintext highlighter-rouge">TIMEOUT</code>.</p>
  </li>
</ol>

<p>When the network is strongly synchronous and has an honest highest priority block proposer, nearly all users who run this <a href="#reduction-procedure"><em>Reduction</em></a> phase will begin with the same <code class="language-plaintext highlighter-rouge">blockHash</code> and also output that hash upon completion. However, if the network is weak given a dishonest proposer, users may begin with different hashes and could result in an <code class="language-plaintext highlighter-rouge">emptyHash</code> output.</p>

<h5 id="reduction-procedure">Reduction procedure</h5>
<p><img src="../../img/a_img_store/alg_reduction.png" alt="image-20221117185619521" /></p>

<h5 id="binaryba-and-consensus">BinaryBA* and Consensus</h5>
<p>The second phase of <code class="language-plaintext highlighter-rouge">BA*</code> consists of performing [<em>BinaryBA**](#binarybastar-procedure), then counting the final resulting votes, and ends by reaching <code class="language-plaintext highlighter-rouge">Final</code> or <code class="language-plaintext highlighter-rouge">Tentative Consensus</code>. This phase runs in at least 2 steps and in the worst case, at most 11 steps. The distribution of steps depends on 2 steps to finalize consensus, and 3 steps per repetition of <a href="#binarybastar-procedure">*BinaryBA<strong>](#binarybastar-procedure) if it is necessary. Each full loop of [*BinaryBA</strong></a> ensures honest users will reach consensus in the next two steps with a chance of <sup>1</sup>/<sub>3</sub>. This results in the expected 2+3*3=11 steps in the worst case. Despite this, Algorand defines <a href="#implementation-parameters">*MaxSteps=150*</a> to ensure that a user will never have a chance of being stuck forever in the case a malicious adversary manipulates the network. If this maximum is reached, Algorand relies on its recovery protocol. The chance of consensus after 150 steps is negligible, at less than 3*10<sup>-9</sup>, thus the reason for this value. A proof for these values can be found in *Appendix C.3</em> in the <a href="https://people.csail.mit.edu/nickolai/papers/gilad-algorand-eprint.pdf">technical report</a>.</p>

<p><a href="#implementation-parameters"><em>BinaryBA**](#binarybastar-procedure) consists of a main 3 step loop and begins with the hash outputted from [</em>Reduction<em>](#reduction-procedure). In every <code class="language-plaintext highlighter-rouge">step</code>, users who find a value with votes that surpass the <code class="language-plaintext highlighter-rouge">threshold</code> will vote for that value in the next step given they are a chosen verifier. Users will use a value <code class="language-plaintext highlighter-rouge">r</code> to track the <code class="language-plaintext highlighter-rouge">blockHash</code> they will potentially use for final consensus. The phase begins first by setting <code class="language-plaintext highlighter-rouge">r</code> equal to the <code class="language-plaintext highlighter-rouge">blockHash</code> they received from [</em>Reduction<em>](#reduction-procedure). <code class="language-plaintext highlighter-rouge">TIMEOUT</code> for every vote count in this phase is set to <code>time<sub>step</sub>=</code>[</em>20 seconds<em>](#implementation-parameters). Votes occur using <code>expectedUsers<sub>step</sub>=</code>[</em>2000<em>](#implementation-parameters) excluding during a <code class="language-plaintext highlighter-rouge">FINAL</code> vote. This loop will break and the network will conduct the recovery process if there is ever the case that the <code class="language-plaintext highlighter-rouge">step</code> count exceeds <code class="language-plaintext highlighter-rouge">MaxSteps=</code>[</em>150*</a>.</p>

<ol>
  <li>In the first step, users will conduct a <a href="#committeevote-procedure"><em>CommitteeVote</em></a> and, if selected, broadcast their <code class="language-plaintext highlighter-rouge">votes</code> for their block hash <code class="language-plaintext highlighter-rouge">r</code>. Users then perform <a href="#countvotes-procedure"><em>CountVotes</em></a> on votes received and set <code class="language-plaintext highlighter-rouge">r</code> equal to the result.
    <ul>
      <li>If the result of <a href="#countvotes-procedure"><em>CountVotes</em></a> is a <code class="language-plaintext highlighter-rouge">TIMEOUT</code>, users assumes the hash agreed on remains the same as the one they received from reduction.</li>
      <li>Otherwise, if the result is not a <code class="language-plaintext highlighter-rouge">TIMEOUT</code> and their current <code class="language-plaintext highlighter-rouge">r</code> is not an <code class="language-plaintext highlighter-rouge">emptyHash</code>, consensus has been reached.
        <ul>
          <li>Users will then attempt <a href="#committeevote-procedure"><em>CommitteeVote</em></a> 3 times for the next 3 steps (step+1 to step+3) all at once to ensure any of their potential votes for <code class="language-plaintext highlighter-rouge">r</code> can still be accounted for by other users if they reach those steps.</li>
          <li>After this, if and only if the current step is 1, users conduct another <a href="#committeevote-procedure"><em>CommitteeVote</em></a> where, if selected, they will broadcast their <code class="language-plaintext highlighter-rouge">votes</code> for <code class="language-plaintext highlighter-rouge">r</code> as <code class="language-plaintext highlighter-rouge">FINAL</code> to the network. This vote is conducted using <code>expectedUsers<sub>final</sub>=</code><a href="#implementation-parameters"><em>10000</em></a> as well as determining <code class="language-plaintext highlighter-rouge">role</code> using some value <code class="language-plaintext highlighter-rouge">FINAL</code> instead of the <code class="language-plaintext highlighter-rouge">step</code> to ensure a new committee is selected. This last <a href="#committeevote-procedure"><em>CommitteeVote</em></a> is guaranteed to occur in the case that the network has strong synchrony and an honest block proposer, meaning that <a href="#binarybastar-procedure">*BinaryBA**</a> completes in only 1 step.</li>
          <li>Finally, <a href="#binarybastar-procedure">*BinaryBA**</a> ends and users return <code class="language-plaintext highlighter-rouge">r</code> to themselves.</li>
        </ul>
      </li>
      <li>If nothing is returned, users move on to the next step.</li>
    </ul>
  </li>
  <li>In the second step, users conduct a <a href="#committeevote-procedure"><em>CommitteeVote</em></a> and, if selected, will again broadcast their <code class="language-plaintext highlighter-rouge">votes</code> for <code class="language-plaintext highlighter-rouge">r</code> to the network, then users run <a href="#countvotes-procedure"><em>CountVotes</em></a> and set <code class="language-plaintext highlighter-rouge">r</code> equal to the result.
    <ul>
      <li>Upon <code class="language-plaintext highlighter-rouge">TIMEOUT</code>, users will set their <code class="language-plaintext highlighter-rouge">r</code> equal to <code class="language-plaintext highlighter-rouge">emptyHash</code>.</li>
      <li>Otherwise, if <code class="language-plaintext highlighter-rouge">r</code> is an <code class="language-plaintext highlighter-rouge">emptyHash</code>, consensus has been reached that the <code class="language-plaintext highlighter-rouge">blockHash</code> will not be chosen.
        <ul>
          <li>Then, users will attempt <a href="#committeevote-procedure"><em>CommitteeVote</em></a> 3 times for the next 3 steps all at once, and upon selection, will broadcast their <code class="language-plaintext highlighter-rouge">votes</code> for the <code class="language-plaintext highlighter-rouge">emptyHash</code>. This occurs upon weak network synchrony, resulting in <code class="language-plaintext highlighter-rouge">TIMEOUTs</code> during this process.</li>
          <li>Finally, <a href="#binarybastar-procedure">*BinaryBA**</a> ends and users return the <code class="language-plaintext highlighter-rouge">emptyHash</code> to themselves.</li>
        </ul>
      </li>
      <li>If nothing is returned, users proceed to the next step.</li>
    </ul>
  </li>
  <li>In the third and last step of a single loop of <a href="#countvotes-procedure"><em>BinaryBA**](#binarybastar-procedure), users conduct another [</em>CommitteeVote<em>](#committeevote-procedure). Selected users will once again broadcast their <code class="language-plaintext highlighter-rouge">votes</code> for <code class="language-plaintext highlighter-rouge">r</code>. Then users run [</em>CountVotes*</a> and set <code class="language-plaintext highlighter-rouge">r</code> equal to the result.
    <ul>
      <li>In the case of a <code class="language-plaintext highlighter-rouge">TIMEOUT</code>, a special procedure called <a href="#commoncoin-procedure"><em>CommonCoin</em></a> is performed (described later on).
        <ul>
          <li>If the result of this procedure is 0, then the user sets <code class="language-plaintext highlighter-rouge">r</code> equal to <code class="language-plaintext highlighter-rouge">blockHash</code> as determined from <a href="#reduction-procedure"><em>Reduction</em></a>.</li>
          <li>Otherwise, <code class="language-plaintext highlighter-rouge">r</code> is set to <code class="language-plaintext highlighter-rouge">emptyHash</code>.</li>
        </ul>
      </li>
      <li>Nothing is returned in this step and users increment their <code class="language-plaintext highlighter-rouge">step</code> counter, go back to the start of the loop, and repeat the <a href="#binarybastar-procedure">*BinaryBA**</a> process again.</li>
    </ul>
  </li>
</ol>

<p>After <a href="#ba-procedure"><em>BinaryBA<strong>](#binarybastar-procedure) concludes, a block hash is returned and stored as <code class="language-plaintext highlighter-rouge">blockHash*</code>. Then, [*CountVotes*](#countvotes-procedure) is performed one last time by all users. This vote count specifically counts all votes from the <code class="language-plaintext highlighter-rouge">FINAL</code> step (which occurs if anyone reached consensus on step 1 of [*BinaryBA</strong>](#binarybastar-procedure)). Users will then set <code class="language-plaintext highlighter-rouge">r</code> equal to the block hash outcome of [</em>CountVotes<em>](#countvotes-procedure). Finally, users will compare <code class="language-plaintext highlighter-rouge">blockHash*</code> and <code class="language-plaintext highlighter-rouge">r</code>. If these values are the same, then <code class="language-plaintext highlighter-rouge">Final Consensus</code> is returned alongside the corresponding <code class="language-plaintext highlighter-rouge">block</code> to the <code class="language-plaintext highlighter-rouge">blockHash*</code>. Otherwise, if these values are not the same, a <code class="language-plaintext highlighter-rouge">Tentative Consensus</code> is returned along with the <code class="language-plaintext highlighter-rouge">block</code> corresponding to the <code class="language-plaintext highlighter-rouge">blockHash*</code>. This Tentative Consensus will be resolved in the future either when a future block reaches Final Consensus and subsequently verifies all blocks before it, or through a recovery process. Recall that Tentative Consensus is only reached if there is weak network synchrony and/or an adversary is controlling the network. You can see this final process described earlier in the [</em>BA**</a> procedure. Once Final Consensus is determined, the <code class="language-plaintext highlighter-rouge">block</code> is appended to the chain.</p>

<p>The <a href="#commoncoin-procedure"><em>CommonCoin</em></a> procedure is a special procedure that acts to prevent an adversary’s ability to manipulate the network by knowing how a user will vote after <code class="language-plaintext highlighter-rouge">TIMEOUT</code> occurs. In a potential attack, consensus could get stuck if honest users are split into two groups wherein group A votes for <code class="language-plaintext highlighter-rouge">emptyHash</code> while group B votes for <code class="language-plaintext highlighter-rouge">blockHash</code>, yet neither can obtain enough votes. However, the adversary could throw the vote to either group by either sending votes for <code class="language-plaintext highlighter-rouge">emptyHash</code> to group A to push that side over the <code class="language-plaintext highlighter-rouge">threshold</code>, or by not casting votes, thus resulting in <code class="language-plaintext highlighter-rouge">blockHash</code> to be chosen. Since the attacker must know how a user will vote after <code class="language-plaintext highlighter-rouge">TIMEOUT</code>, <a href="#commoncoin-procedure"><em>BinaryBA**](#binarybastar-procedure) runs a [</em>CommonCoin*</a> procedure during the third loop step to make the decision after <code class="language-plaintext highlighter-rouge">TIMEOUT</code> unknown beforehand. This must output a binary bit of either 0 or 1, which determines whether to accept <code class="language-plaintext highlighter-rouge">blockHash</code> or <code class="language-plaintext highlighter-rouge">emptyHash</code>. The goal of this procedure is to provide a method such that enough users can observe the same bit output while ensuring the adversary cannot determine the value beforehand, thus it can run without formal consensus from the entire network. In short, the procedure finds the <code class="language-plaintext highlighter-rouge">minhash</code> (or smallest hash) out of all <code class="language-plaintext highlighter-rouge">votes</code> received in the step, and uses it to determine 0 or 1.</p>

<p>This <a href="#commoncoin-procedure"><em>CommonCoin</em></a> procedure executes as follows. Firstly, all <code class="language-plaintext highlighter-rouge">messages</code> from verifiers are recorded during the third loop step and processed through <a href="#processmsg-procedure"><em>ProcessMsg</em></a> to verify and extract the sortition <code class="language-plaintext highlighter-rouge">hash</code> and <code class="language-plaintext highlighter-rouge">votes</code>. Then, for each <code class="language-plaintext highlighter-rouge">message</code>, given the its <code class="language-plaintext highlighter-rouge">vote</code> count, for each <code class="language-plaintext highlighter-rouge">index</code> 1, 2, … up to the <code class="language-plaintext highlighter-rouge">vote</code> count, the user will concatenate the <code class="language-plaintext highlighter-rouge">hash</code> with the <code class="language-plaintext highlighter-rouge">index</code>, then use a hash function to output a hash <code class="language-plaintext highlighter-rouge">h</code>. Essentially, this will run as many times as there are <code class="language-plaintext highlighter-rouge">votes</code> in all the <code class="language-plaintext highlighter-rouge">messages</code>, then the smallest <code class="language-plaintext highlighter-rouge">h</code> hash will be chosen as the <code class="language-plaintext highlighter-rouge">minhash</code>. Finally, the user calculates a binary value <code class="language-plaintext highlighter-rouge">h mod 2</code> to obtain either 0 or 1, which becomes the output of <a href="#commoncoin-procedure"><em>CommonCoin</em></a>.</p>

<h5 id="binaryba-procedure">BinaryBA* procedure</h5>
<p><img src="../../img/a_img_store/alg_binarybastar.png" alt="image-20221117185619521" /></p>

<h5 id="commoncoin-procedure">CommonCoin procedure</h5>
<p><img src="../../img/a_img_store/alg_commoncoin.png" alt="image-20221117185619521" /></p>

<h2 id="conclusion">Conclusion</h2>
<p>As a short summary, I’ll go over the entire thing once more in brief. So consensus relies heavily on a concept called <a href="#cryptographic-sortition"><strong>Cryptographic Sortition</strong></a> to hide user identities until they have already broadcasted their completely verifiable work. At the start of each round, a block is chosen during <a href="#block-proposal"><strong>Block Proposal</strong></a> by using sortition’s output to calculate the proposer with the highest priority to be the official block proposer. Then, the hash of this block is passed to <a href="#ba"><strong>BA</strong>*</a> in which several committee votes are run, again using sortition. Users vote on hashes as they receive votes and hashes while they propagate around the network, and by this process the network can together whittle down the results down to consensus on a proposed block or an empty block, then finally down to consensus on a single final hash, all the while working to keep any adversary’s malicious tactics at bay. The block corresponding to that hash is then appended onto the chain! An additional property of Algorand’s consensus protocol is that users do not need to be in perfect time sync and can still perform in an asynchronous environment, instead they simply need to have the same ‘rate’ of time such that all steps and processes perform in the designated time frame.</p>

<p>Phew! That’s it for now, I won’t go on any longer. I’m glad to see you stayed around till the end! I hope this provides a deeper understanding of the exact processes Algorand uses to perform its instant consensus protocol. It’s quite complex, and rightfully so for all that it is able to achieve to maximize so many major features such as scalability, security, and decentralization. If you want to keep delving into the specifics of Algorand and all the proofs and algorithms not described here, or find helpful summaries of all the processes, be sure to check out the <a href="#further-reading"><strong>Further Reading</strong></a> section. Thanks for reading, and see you around!</p>

<h2 id="glossary">Glossary</h2>
<p>A collection of terms referenced, collected in a convenient location</p>
<ul>
  <li><strong>BA</strong>*: a type of Byzantine Agreement protocol designed and used by Algorand to vote on blocks</li>
  <li><strong>block proposer</strong>: a selected user who may propose their block to the network to potentially be verified</li>
  <li><strong>broadcast</strong>: see ‘gossip’</li>
  <li><strong>Byzantine Agreement</strong>: a protocol that attempts to achieve consensus on a single outcome even if certain components are unreliable or malicious</li>
  <li><strong>committee</strong>: the group of users who act as verifiers for a block as it propagates through the network</li>
  <li><strong>committee member</strong>: an individual user in a committee</li>
  <li><strong>cryptographic sortition</strong>: a process to verifiably select a small amount of users from a large set weighted based on account balance and some randomness</li>
  <li><strong>gossip</strong>: the term used by Algorand to describe the process of propagating messages through a network</li>
  <li><strong>priority</strong>: a hash used to rank block proposers. The highest priority proposer’s block becomes the chosen block for verification.</li>
  <li><strong>proof</strong>: a piece of data produced through VRFs that can be used to verify your selection status</li>
  <li><strong>role</strong>: a value recalculated every step to ensure a different set of selected users for every step</li>
  <li><strong>round</strong>: akin to the ‘height’ of the block chain. A single round consists of one proposal and agreement procedure</li>
  <li><strong>seed</strong>: a value used in cryptographic sortition to obtain the same selected users for any step of consensus</li>
  <li><strong>step</strong>: each round in BA* consists of several steps, with at most 13 steps</li>
  <li><strong>subUser</strong>: in the selection process, having more than 0 subUsers means you are selected. In proposer selection, the number of subUsers is the number of ‘tries’ you have to obtain your highest priority. In verifier selection, the number of subUsers is the number of votes you cast</li>
  <li><strong>verifier</strong>: see ‘committee member’</li>
  <li><strong>VRF</strong>: a pseudo-random function that provides publicly verifiable proofs of its outputs’ correctness</li>
</ul>

<h2 id="further-reading">Further Reading</h2>
<ul>
  <li><em>Algorand’s Website:</em> https://www.algorand.com/</li>
  <li><em>Algorand: Scaling Byzantine Agreements for Cryptocurrencies:</em> https://dl.acm.org/citation.cfm?id=3132757</li>
  <li><em>Algorand Theoretical Paper:</em> https://arxiv.org/pdf/1607.01341.pdf</li>
  <li><em>Algorand’s Instant Consensus Protocol:</em> https://medium.com/algorand/algorands-instant-consensus-protocol-e66ac5807e37</li>
  <li><em>Algorand Slides:</em> https://web.eecs.umich.edu/~manosk/assets/slides/w18/algorand.pdf</li>
  <li><em>Verifiable Random Functions (VRFs):</em> https://www.cs.bu.edu/~goldbe/projects/vrf</li>
</ul>


                <br>
          <br>
    <br>


<!--               <div class="post-author text-center">                       
	        <img src="/tech-notebook/img/" alt="'s photo" itemprop="image" class="post-avatar img-circle img-responsive"/>    
	    <h4>By <span itemprop="name" class="fn"><a href="/tech-notebook/about/" title="About " itemprop="url"></a></span></h4>
	    <div style="font-family: Open Sans, Helvetica Neue, Helvetica, Arial, sans-serif; display:inline-block;font-size:.75em;"></div>
</div> -->
    <hr class="small">
 <div class="post-share text-center">
    <p class="light small">
        <h6>END OF POST</h6>
    </p>
    <ul class="social-mini">

    </ul>
</div>
                        

                        
                <br>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/tech-notebook/journal/96/" data-toggle="tooltip" data-placement="top" title="Hybrid Transactional Analytical Processing A Survey">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/tech-notebook/journal/101/" data-toggle="tooltip" data-placement="top" title="TETRIS Memory efficient Serverless Inference through Tensor Sharing">Next Post &rarr;</a>
                    </li>
                    
                </ul>

        </div>
    </div>
</article>

<br>

<hr class="medium">

            <div class="tags-wrap">
   <div class="tags">

  <div class="section-heading group" style="color: #fff; text-align: center; margin-top: 10px;">

    <h3>Tags Cloud</h3>

  </div>










  <div class="tag-list">
    
  </div>

</div>

<hr class="medium">

<div class="categories">

  <div class="section-heading group" style="color: #fff; text-align: center; margin-top: 10px;">

    <h3>Categories Cloud</h3>

  </div>

 









 <div class="category-list">
   
<a href="/tech-notebook/journal/category//">  </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/a-paper-note/"> A paper note </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/cmu-database/"> CMU database </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/coding/"> coding </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/devices/"> devices </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/distributed-database/"> distributed database </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/machine-learning-basic/"> machine learning basic </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/operation-system/"> operation system </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/practise/"> practise </a> &nbsp;&nbsp;

<a href="/tech-notebook/journal/category/programming-language/"> programming language </a> &nbsp;&nbsp;

  </div>

</div>

<hr class="medium">

<br>
<br>

       </div>


<!-- jQuery -->    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<!-- Custom Theme JavaScript -->
<script src="/tech-notebook/js/main.min.js "></script>
<!-- include image popups -->
<script src="/tech-notebook/js/jquery.magnific-popup.js"></script>

<script type="text/javascript">
      $(document).ready(function($) {
        $('a.popup').magnificPopup({
         type: 'image',
	  gallery:{
         enabled:true,
         navigateByImgClick: true,
         preload: [0,1] // Will preload 0 - before current, and 1 after the current image
       },
image: {
      titleSrc: function(item) {
              return item.el.attr('title') + '&nbsp;' + item.el.attr('data-caption');
            }
        }
          // other options
      });
});
    </script>

<script src="/tech-notebook/js/retina.min.js"></script>
<!-- include Masonry -->
<script src="/tech-notebook/js/isotope.pkgd.min.js"></script> 
<!-- include mousewheel plugins -->
<script src="/tech-notebook/js/jquery.mousewheel.min.js"></script>
<!-- include carousel plugins -->
<script src="/tech-notebook/js/jquery.tinycarousel.min.js"></script>
<!-- include svg line drawing plugin -->
<script src="/tech-notebook/js/jquery.lazylinepainter.min.js"></script>
<!-- include custom script -->
<script src="/tech-notebook/js/scripts.js"></script>
<!-- Modernizr -->
 <script src="/tech-notebook/js/modernizr.js"></script>

</body>
</html>






    <a href="javascript:void(0)" title="SEARCH" onclick="superSearch.toggle()" class="super-search-btn">
<span class="fa fa-search" style="font-size:1em; position:fixed; right: .75em; top: 1em; z-index: 2;"></span>
</a>
<div class="super-search" id="js-super-search">
<a href="javascript:void(0)" onclick="superSearch.toggle()" class="super-search__close-btn"">
<span class="fa fa-close" style="font-size:48px;"></span>
</a>
<input type="text" placeholder="Type here to search" class="super-search__input" id="js-super-search__input">
<ul class="super-search__results" id="js-super-search__results"></ul>
</div>



 <script src="/tech-notebook/js/super-search.js"></script>

<script>
superSearch({
    searchFile: '/tech-notebook/feed.xml',
    searchSelector: '#js-super-search', // CSS Selector for search container element.
    inputSelector: '#js-super-search__input', // CSS selector for <input>
    resultsSelector: '#js-super-search__results' // CSS selector for results container
});
</script>

    
        <div class="row"  style="background-color: #530720; padding-bottom: 40px; margin-top: 50px; margin-bottom: 80px;">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

      <center><h4><p>It's the niceties that make the difference fate gives us the hand, and we play the cards.</h4></center>


<!--<form style="padding:3px;text-align:center;font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:12px;" action="https://tinyletter.com/photorgasms" method="post" target="popupwindow" onsubmit="window.open('https://tinyletter.com/yourproject', 'popupwindow', 'scrollbars=yes,width=800,height=600');return true"><input type="text" placeholder="Enter your email address"  style="width:200px;height:30px;border:0;background-color:#5A0F28;color:#dddddd;outline:0;padding-left:12px;" name="email" id="tlemail" />&nbsp; &nbsp; <input type="submit" value="Get notified!" style="background-color:#470118;color:#dddddd;height:30px;border:0;" /></form>-->
            </div>
        </div>
     
<style type="text/css">
        .tlemail::-webkit-input-placeholder {
   color: rgba(255,255,255,.45);
}
       .tlemail:-moz-placeholder { /* Firefox 18- */
   color: rgba(255,255,255,.45);  
}

      .tlemail::-moz-placeholder {  /* Firefox 19+ */
   color: rgba(255,255,255,.45);  
}

      .tlemail:-ms-input-placeholder {  
   color: rgba(255,255,255,.45);  
}
    </style>


    <!-- Footer -->
<footer>
<div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

                <ul class="list-inline text-center">

<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://facebook.com/" data-toggle="tooltip" title="Facebook">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://twitter.com/" data-toggle="tooltip" title="Twiiter">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://instagram.com/" data-toggle="tooltip" title="Instagram">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="https://flickr.com/photos/" data-toggle="tooltip" title="Flickr">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-flickr fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
<!--                    -->
<!--                    <li>-->
<!--                        <a href="http://.deviantart.com">-->
<!--                            <span class="fa-stack fa-lg" data-toggle="tooltip" title="Deviantart">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-deviantart fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
<!--                    -->
                    
                    <li>
                        <a href="https://github.com/NLGithubWP/tech-notebook" data-toggle="tooltip" title="Github">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
<!--            <li>-->
<!--    <a href="mailto:" data-toggle="tooltip" target="_blank" title="Email">-->
<!--                       <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>-->
<!--</span>-->
<!--          </a> </li>-->

<!--         <li>-->
<!--                        <a href="/tech-notebook/feed.xml" data-toggle="tooltip" title="Feed">-->
<!--                            <span class="fa-stack fa-lg">-->
<!--                                <i class="fa fa-circle fa-stack-2x"></i>-->
<!--                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>-->
<!--                            </span>-->
<!--                        </a>-->
<!--                    </li>-->
                </ul>
                <p class="copyright text-muted">Copyright &copy; NoteBook 2025</p>
<center><h6><p>Powered by <a href="https://github.com/jekyll/">Jekyll</a>.</p></h6></center>
            </div>
        </div>
    </div>
</footer>


   <script>
//** jQuery Scroll to Top Control script- (c) 
//** v1.1 (April 7th, 10')
//** 1) Adds ability to scroll to an absolute position (from top of page) or specific element on the page instead.
//** 2) Fixes scroll animation not working in Opera. 
var scrolltotop={
//startline: Integer. Number of pixels from top of doc scrollbar is scrolled before showing control
//scrollto: Keyword (Integer, or "Scroll_to_Element_ID"). How far to scroll document up when control is clicked on (0=top).
setting: {startline:100, scrollto: 0, scrollduration:1000, fadeduration:[500, 100]},
controlHTML: '<img src="https://cloud.githubusercontent.com/assets/14811095/13691821/88412468-e744-11e5-8bb5-94340afd92e7.png" style="filter:alpha(opacity=100); -moz-opacity:1;"/>', //HTML for control, which is auto wrapped in DIV w/ ID="topcontrol"
controlattrs: {offsetx:35, offsety:60}, //offset of control relative to right/ bottom of window corner
anchorkeyword: '#top', //Enter href value of HTML anchors on the page that should also act as "Scroll Up" links
state: {isvisible:false, shouldvisible:false},
scrollup:function(){
if (!this.cssfixedsupport) //if control is positioned using JavaScript
this.$control.css({opacity:0}) //hide control immediately after clicking it
var dest=isNaN(this.setting.scrollto)? this.setting.scrollto : parseInt(this.setting.scrollto)
if (typeof dest=="string" && jQuery('#'+dest).length==1) //check element set by string exists
dest=jQuery('#'+dest).offset().top
else
dest=0
this.$body.animate({scrollTop: dest}, this.setting.scrollduration);
},
keepfixed:function(){
var $window=jQuery(window)
var controlx=$window.scrollLeft() + $window.width() - this.$control.width() - this.controlattrs.offsetx
var controly=$window.scrollTop() + $window.height() - this.$control.height() - this.controlattrs.offsety
this.$control.css({left:controlx+'px', top:controly+'px'})

},

togglecontrol:function(){
var scrolltop=jQuery(window).scrollTop()
if (!this.cssfixedsupport)
this.keepfixed()
this.state.shouldvisible=(scrolltop>=this.setting.startline)? true : false
if (this.state.shouldvisible && !this.state.isvisible){
this.$control.stop().animate({opacity:1}, this.setting.fadeduration[0])
this.state.isvisible=true
}
else if (this.state.shouldvisible==false && this.state.isvisible){
this.$control.stop().animate({opacity:0}, this.setting.fadeduration[1])
this.state.isvisible=false
}

},
init:function(){
jQuery(document).ready(function($){
var mainobj=scrolltotop
var iebrws=document.all

mainobj.cssfixedsupport=!iebrws || iebrws && document.compatMode=="CSS1Compat" && window.XMLHttpRequest //not IE or IE7+ browsers in standards mode
mainobj.$body=(window.opera)? (document.compatMode=="CSS1Compat"? $('html') : $('body')) : $('html,body')
mainobj.$control=$('<div id="topcontrol">'+mainobj.controlHTML+'</div>')
.css({position:mainobj.cssfixedsupport? 'fixed' : 'absolute', bottom:mainobj.controlattrs.offsety, right:mainobj.controlattrs.offsetx, opacity:0, cursor:'pointer'})
.attr({title:'Scroll To Top'})
.click(function(){mainobj.scrollup(); return false})
.appendTo('body')

if (document.all && !window.XMLHttpRequest && mainobj.$control.text()!='') //loose check for IE6 and below, plus whether control contains any text
mainobj.$control.css({width:mainobj.$control.width()}) //IE6- seems to require an explicit width on a DIV containing text
mainobj.togglecontrol()

$('a[href="' + mainobj.anchorkeyword +'"]').click(function(){
mainobj.scrollup()

return false
})

$(window).bind('scroll resize', function(e){

mainobj.togglecontrol()

})

})

}

}

scrolltotop.init()
</script>  

</body>

</html>
