I"É0<h1 id="1-search-for-range">1. <a href="https://leetcode-cn.com/problems/binary-search/">search for range</a></h1>

<pre><code class="language-go">func search(nums []int, target int) int {
	left := 0
	right := len(nums)-1
  // must == mid,  otherwise it's not log(n)
	for left+1 &lt; right{
		mid := (left + right) / 2
		if nums[mid] == target{
			return mid
		}else if nums[mid] &lt; target {
			left = mid
		}else{
			right = mid
		}
	}
	if nums[left] == target{
		return left
	}
    if nums[right] == target{
		return right
	}
	
	return -1
}
</code></pre>

<h1 id="2-search-insert-position">2. <a href="https://leetcode-cn.com/problems/search-insert-position/">Search Insert Position</a></h1>

<pre><code class="language-go">func searchInsert(nums []int, target int) int {
	left :=  0
	right := len(nums)-1
	for left  + 1&lt; right{
		mid := (left + right)/2
		if nums[mid] &lt; target{
			left=mid 
		}else{
			right=mid
		}
	}

	if nums[left] &gt;= target{
		return left
	}else if nums[right] &gt;= target{
		return right
	}else{
        return right+1
    }
}
</code></pre>

<h1 id="3-search-a-2d-matrix">3. <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a></h1>

<pre><code class="language-go">func searchMatrix(matrix [][]int, target int) bool {
	m := len(matrix)-1
	n := len(matrix[0])-1
	target_row := -1
	
	for i:=0;i&lt;=m;i++{
		if matrix[i][n] &gt;= target{
			target_row = i
			break
		}
	}
	if target_row == -1{
		return false
	}
	
  // do a binary search at target row
	left := 0
	right := n
	
	for left + 1 &lt; right{
		mid := (left+right)/2
		if matrix[target_row][mid] == target{
			return true
		}else if matrix[target_row][mid] &gt; target{
			right = mid
		}else{
			left = mid
		}
	}
	 if matrix[target_row][left] == target || matrix[target_row][right] == target{
	 	return true
	 }
	 return false
}

</code></pre>

<h1 id="4-find-first-and-last-position-of-element-in-sorted-array">4. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></h1>

<pre><code class="language-go">func searchRange(nums []int, target int) []int {

	l := -1
	r := -1
	if len(nums) == 0{
		return []int{l,r}
	}

	// twice binary search, left bound
	left := 0
	right := len(nums)-1
	for left + 1 &lt; right{
		mid := (left+right)/2
		if nums[mid] &gt;= target{
			right = mid
		}else{
			left = mid
		}
	}
	if nums[left] &gt; target{
		return []int{l,r}
	}
	if nums[right] &lt; target{
		return []int{l,r}
	}
	// use, else if else, otherwise ,l is re-writen
	if nums[left] == target{
		l = left
	}else if nums[right] == target{
		l = right
	}

	// twice binary search, right bound
	left = 0
	right = len(nums)-1
	for left + 1 &lt; right{
		mid := (left+right)/2
		if nums[mid] &lt;= target{
			left = mid
		}else{
			right = mid
		}
	}
	if nums[left] == target{
		r = left
	}
	if nums[right] == target{
		r = right
	}

	return []int{l, r}
}
</code></pre>

<h1 id="5-first-bad-version">5.<a href="https://leetcode-cn.com/problems/first-bad-version/"> First Bad Version</a></h1>

<pre><code class="language-go">func firstBadVersion(n int) int {
	left := 1
	right := n
  
  // if using righ++ or left ++, it will timeout 
	for left + 1 &lt; right{
		mid := (left + right)/2
		if isBadVersion(mid) {
			right = mid
		}else{
			left = mid
		}
	}
	if isBadVersion(left){
		return left
	}else{
		return right
	}
}
</code></pre>

<h1 id="6-find-minimum-in-rotated-sorted-array">6. <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated Sorted Array</a></h1>

<pre><code class="language-go">func findMin(nums []int) int {
	left :=  0
	right := len(nums)-1

	for left + 1 &lt; right {
		mid := (left + right)/2
		if nums[mid] &gt; nums[len(nums)-1]{
			left = mid
		}else if nums[mid] &lt; nums[len(nums)-1]{
			right = mid
		}
	}

	if nums[left]  &lt; nums[right]{
		return nums[left]
	}else{
		return nums[right]
	}
}
</code></pre>

<h1 id="7-find-minimum-in-rotated-sorted-array-iiå¸¦é‡å¤çš„æ—‹è½¬æ•°ç»„å¦‚æœmidå’Œæœ€å³å€¼ç›¸ç­‰ç»å¯¹æœ‰ä¸€è¾¹çš„å€¼å…¨éƒ½ä¸€æ ·">7. <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">Find Minimum in Rotated Sorted Array II</a>ï¼ˆå¸¦é‡å¤çš„æ—‹è½¬æ•°ç»„ï¼Œå¦‚æœmidå’Œæœ€å³å€¼ç›¸ç­‰ï¼Œç»å¯¹æœ‰ä¸€è¾¹çš„å€¼å…¨éƒ½ä¸€æ ·ï¼‰</h1>

<pre><code class="language-go">func findMin(nums []int) int {
	left := 0
	right := len(nums)-1
  // binary search
	for left + 1 &lt; right{
		mid := (left + right)/2
		if nums[mid] &gt; nums[len(nums)-1]{
			left = mid
		}else if nums[mid] &lt; nums[len(nums)-1]{
			right = mid
		// if equal, go through left and right      
		}else{
			if findMinHelper(nums, mid, &amp;left, &amp;right){
				return nums[mid]
			}
		}
	}

	if nums[left] &lt; nums[right]{
		return nums[left]
	}else{
		return nums[right]
	}
}

// if [3 1 3 3] or [3 3 1 3]
// go through left and right, until find min value, 
// if return true, means all value are the same, nums is like [ 1 1 1] etc
// if return false, still need to use binary search
func findMinHelper(nums []int, mid int, left *int, right *int) bool{
	for i := mid; i &lt; len(nums)-1; i++{
		if nums[i] &gt; nums[i+1]{
			*left = mid
			return false
		}
	}

	for j := mid; j &gt;0; j--{
		if nums[j] &gt; nums[j-1]{
			*right = mid
			return false
		}
	}
	return true
}
</code></pre>

<h1 id="8-search-in-rotated-sorted-array">8. <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">Search in Rotated Sorted Array</a></h1>

<pre><code class="language-go">func search(nums []int, target int) int {
	left := 0
	right := len(nums)-1

	for left + 1 &lt; right{
		mid := (left+right)/2
		if nums[mid] == target{
			return mid
		// if not equal, åˆ†4æ®µï¼Œæ ¹æ®midå’Œå·¦å³è¾¹ç•Œï¼Œæ¥å®šç•Œtargetçš„ä½ç½®
		}else{
			if nums[len(nums)-1] &lt; nums[mid]{
				if target &lt; nums[mid] &amp;&amp; target &gt;= nums[0] {
					right = mid
				}else{
					left = mid
				}
			}else {
				if target &gt; nums[mid] &amp;&amp; target &lt;= nums[len(nums)-1]{
					left = mid
				} else{
					right = mid
				}
			}
		}
	}
	if nums[left] == target{
		return left
	}
	if nums[right] == target{
		return right
	}
	return -1
}
</code></pre>

<h1 id="9--search-in-rotated-sorted-array-iiå¸¦é‡å¤çš„æ—‹è½¬æ•°ç»„å¦‚æœmidå’Œæœ€å³å€¼ç›¸ç­‰ç»å¯¹æœ‰ä¸€è¾¹çš„å€¼å…¨éƒ½ä¸€æ ·">9. <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/"> Search in Rotated Sorted Array II</a>å¸¦é‡å¤çš„æ—‹è½¬æ•°ç»„ï¼Œå¦‚æœmidå’Œæœ€å³å€¼ç›¸ç­‰ï¼Œç»å¯¹æœ‰ä¸€è¾¹çš„å€¼å…¨éƒ½ä¸€æ ·ï¼‰</h1>

<pre><code class="language-go">func search(nums []int, target int) bool {

	left := 0
	right := len(nums)-1

	for left + 1 &lt; right {
		mid := (left + right)/2
		if nums[mid] == target{
			return true
		}else{
			if nums[mid] &gt; nums[len(nums)-1]{
				if target &lt; nums[mid] &amp;&amp; target &gt;= nums[0]{
					right = mid
				}else{
					left = mid
				}
			}else if nums[mid] &lt; nums[len(nums)-1]{
				if target &gt; nums[mid] &amp;&amp; target &lt;= nums[len(nums)-1]{
					left = mid
				}else{
					right = mid
				}
//å¦‚æœç­‰äºï¼Œå¼€å§‹å·¦å³éå†
			}else{
				if helper(nums, &amp;left, &amp;right, mid){
					return false
				}
			}

		}
	}

	if nums[left] == target || nums[right] == target{
		return true
	}else{
		return false
	}
}

// æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç›¸ç­‰çš„
func helper(nums []int, left *int, right *int, mid int) bool{
	for i:=mid; i&lt;len(nums)-1; i++{
		if nums[i] != nums[i+1]{
			*left = mid
			return false
		}
	}
	for j:=mid; j&gt;0; j--{
		if nums[j] != nums[j-1]{
			*right = mid
			return false
		}
	}
	return true
}
</code></pre>

<h1 id="10-find-peak-element">10. <a href="https://leetcode-cn.com/problems/find-peak-element/">Find Peak Element</a></h1>

<pre><code class="language-go">func findPeakElement(nums []int) int {
	if len(nums) ==1{
		return 0
	}
	left := 0
	right := len(nums)-1
	for left + 1 &lt; right{
		mid := (left + right)/2
    // 2 åˆ†æœç´¢ï¼Œ 
		if nums[mid] &gt; nums[mid-1] &amp;&amp; nums[mid] &gt; nums[mid+1]{
			return mid
		}else if nums[mid] &gt; nums[mid-1]{
			left = mid
		}else{
			right = mid
		}
	}
	if nums[left] &gt; nums[right]{
		return left
	}else{
		return right
	}
}
</code></pre>

<h1 id="11--find-k-closest-elements">11. <a href="https://leetcode-cn.com/problems/find-k-closest-elements/"> Find K Closest Elements</a></h1>

<pre><code class="language-go">func findClosestElements(arr []int, k int, x int) []int {
	// binary search find most close value to x
	left := 0
	right := len(arr)-1
	var pos int
	for left + 1 &lt; right{
		mid := (left + right)/2
		if arr[mid] == x{
			pos = mid
			break
		}else if arr[mid] &gt; x{
			right = mid
		}else{
			left = mid
		}
	}
	// two pointer, find most recent value
	lp := 0
	rp := 0
	if pos==0{
		lp = left
		rp = right
	}else{
		lp = pos
		rp = pos+1
	}
	var res []int

	// append most recent value to res
	for len(res) !=k{
		res = append(res, closer(arr, &amp;lp, &amp;rp, x))
	}
	// do a sort
	sort.Ints(res)
	return res
}

func closer(arr []int, i *int, j *int, x int) int {
	// if either i or j reach bound, only use another one
	if *i &lt; 0 &amp;&amp; *j &lt;= len(arr)-1{
		res := arr[*j]
		*j++
		return res
	}else if *i &gt;= 0 &amp;&amp; *j &gt; len(arr)-1{
		res := arr[*i]
		*i--
		return res
	}
	// if not, append the most recent value	
	a := arr[*i]
	b := arr[*j]
	if abs(a-x) &lt; abs(b-x){
		*i--
		return a
	}else if abs(a-x) &gt; abs(b-x){
		*j++
		return b
	}else{
		if *i&lt;*j{
			*i--
			return a
		}else{
			*j++
			return b
		}
	}
}

func abs(a int)int{
	if a&lt;0{
		return -a
	}else{
		return a
	}
}
</code></pre>

<h1 id="12-closest-binary-search-tree-value">12. <a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">Closest Binary Search Tree Value</a></h1>

<pre><code class="language-go">func closestValue(root *TreeNode, target float64) int {
	var res int
	dist := math.MaxFloat64
	for root!=nil{
		// check distance of each node
		tmp := abs(float64(root.Val) - target)
		if tmp &lt; dist{
			dist = tmp
			res = root.Val
		}
		if target &gt;= float64(root.Val){
			root = root.Right
		}else{
			root = root.Left
		}
	}
	return res
}

func abs(a float64)float64{
	if a&gt;0{return a}else{return -a}
}
</code></pre>

<h1 id="13-åœ¨å¤§æ•°ç»„ä¸­æŸ¥æ‰¾">13. åœ¨å¤§æ•°ç»„ä¸­æŸ¥æ‰¾</h1>

<p>ç»™ä¸€ä¸ªæŒ‰ç…§å‡åºæ’åºçš„éè´Ÿæ•´æ•°æ•°ç»„ã€‚è¿™ä¸ªæ•°ç»„å¾ˆå¤§ä»¥è‡³äºä½ åªèƒ½é€šè¿‡å›ºå®šçš„æ¥å£ ArrayReader.get(k) æ¥è®¿é—®ç¬¬kä¸ªæ•°(æˆ–è€…C++é‡Œæ˜¯ArrayReader-&gt;get(k))ï¼Œå¹¶ä¸”ä½ ä¹Ÿæ²¡æœ‰åŠæ³•å¾—çŸ¥è¿™ä¸ªæ•°ç»„æœ‰å¤šå¤§ã€‚</p>

<p>æ‰¾åˆ°ç»™å‡ºçš„æ•´æ•°targetç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚ä½ çš„ç®—æ³•éœ€è¦åœ¨O(logk)çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆï¼Œkä¸ºtargetç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®çš„ä¸‹æ ‡ã€‚</p>

<p>å¦‚æœæ‰¾ä¸åˆ°targetï¼Œè¿”å›-1ã€‚</p>

<p>æ ·ä¾‹
æ ·ä¾‹ 1:</p>

<p>è¾“å…¥: [1, 3, 6, 9, 21, â€¦], target = 3
è¾“å‡º: 1
æ ·ä¾‹ 2:</p>

<p>è¾“å…¥: [1, 3, 6, 9, 21, â€¦], target = 4
è¾“å‡º: -1
æŒ‘æˆ˜
O(logn)çš„æ—¶é—´å¤æ‚åº¦ï¼Œnæ˜¯targetç¬¬ä¸€æ¬¡å‡ºç°çš„ä¸‹æ ‡ã€‚</p>

<p>å¦‚æœä½ è®¿é—®äº†ä¸€ä¸ªä¸å¯è®¿é—®çš„ä¸‹æ ‡ï¼ˆæ¯”å¦‚è¶Šç•Œï¼‰ï¼ŒArrayReader ä¼šè¿”å›<code>2147483647</code>ã€‚</p>

<pre><code class="language-go">type ArrayReader struct {}

func (this *ArrayReader) get(index int) int {return 1}

func search(reader ArrayReader, target int) int {
	// You may assume all integers in the array are less than 10000
	// ç¬¬ä¸€æ¬¡äºŒåˆ†æœç´¢æ‰¾è¾¹ç•Œ
	left := 0
	right := 10000
	for left+1&lt;right{
		mid := (left+right)/2
		if reader.get(mid) &lt; 2147483647{
			left = mid
		}else{
			right=mid
		}
	}
	if reader.get(right)&lt;2147483647{
		right = right
	}else if reader.get(left)&lt;2147483647{
		right = left
	}
	left = 0
	// ç¬¬äºŒæ¬¡äºŒåˆ†æœç´¢æ‰¾å€¼
	for left+1&lt;right{
		mid := (left+right)/2
		if reader.get(mid)&gt;target{
			right = mid
		}else if reader.get(mid)&lt;target {
			left = mid
		}else{
			return mid
		}
	}

	if reader.get(right)==target{
		return right
	}else if reader.get(left)==target{
		return left
	}else{
		return -1
	}
}
</code></pre>

<h1 id="14-powx-n">14. <a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h1>

<pre><code class="language-go">func myPow(x float64, n int) float64 {
	if n &gt; 0{
		return helper(x, n)
	}else{
		return 1/helper(x, -n)
	}
}

func helper(x float64, n int)float64{
	if n == 0{return 1}
	y :=  helper(x, n/2)
	if n % 2 == 0{
		return y*y
	}else{
		return y*y*x
	}
}
</code></pre>

:ET